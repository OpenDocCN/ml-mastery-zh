["```py\nimport pandas as pd\ndata = pd.read_csv(\"iris.csv\", header=None)\nX = data.iloc[:, 0:4]\ny = data.iloc[:, 4:]\n```", "```py\nIris-setosa      1   0   0\nIris-versicolor  0   1   0\nIris-virginica   0   0   1\n```", "```py\nfrom sklearn.preprocessing import OneHotEncoder\nohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(y)\nprint(ohe.categories_)\n\ny = ohe.transform(y)\nprint(y)\n```", "```py\n[array(['Iris-setosa', 'Iris-versicolor', 'Iris-virginica'], dtype=object)]\n```", "```py\n[[1\\. 0\\. 0.]\n [1\\. 0\\. 0.]\n [1\\. 0\\. 0.]\n...\n [0\\. 0\\. 1.]\n [0\\. 0\\. 1.]\n [0\\. 0\\. 1.]]\n```", "```py\n[4 inputs] -> [8 hidden neurons] -> [3 outputs]\n```", "```py\nimport torch\nimport torch.nn as nn\n\nclass Multiclass(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.hidden = nn.Linear(4, 8)\n        self.act = nn.ReLU()\n        self.output = nn.Linear(8, 3)\n\n    def forward(self, x):\n        x = self.act(self.hidden(x))\n        x = self.output(x)\n        return x\n\nmodel = Multiclass()\n```", "```py\nimport torch.optim as optim\n\nloss_fn = nn.<span class=\"sig-name descname\"><span class=\"pre\">CrossEntropyLoss</span></span>()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n```", "```py\nimport tqdm\n\n# convert pandas DataFrame (X) and numpy array (y) into PyTorch tensors\nX = torch.tensor(X.values, dtype=torch.float32)\ny = torch.tensor(y, dtype=torch.float32)\n\n# training parameters\nn_epochs = 200\nbatch_size = 5\nbatches_per_epoch = len(X) // batch_size\n\nfor epoch in range(n_epochs):\n    with tqdm.trange(batches_per_epoch, unit=\"batch\", mininterval=0) as bar:\n        bar.set_description(f\"Epoch {epoch}\")\n        for i in bar:\n            # take a batch\n            start = i * batch_size\n            X_batch = X[start:start+batch_size]\n            y_batch = y[start:start+batch_size]\n            # forward pass\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            # backward pass\n            optimizer.zero_grad()\n            loss.backward()\n            # update weights\n            optimizer.step()\n```", "```py\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import OneHotEncoder\n\n# read data and apply one-hot encoding\ndata = pd.read_csv(\"iris.csv\", header=None)\nX = data.iloc[:, 0:4]\ny = data.iloc[:, 4:]\nohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(y)\ny = ohe.transform(y)\n\n# convert pandas DataFrame (X) and numpy array (y) into PyTorch tensors\nX = torch.tensor(X.values, dtype=torch.float32)\ny = torch.tensor(y, dtype=torch.float32)\n\n# split\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, shuffle=True)\n```", "```py\nn_epochs = 200\nbatch_size = 5\nbatches_per_epoch = len(X_train) // batch_size\n\nfor epoch in range(n_epochs):\n    with tqdm.trange(batches_per_epoch, unit=\"batch\", mininterval=0) as bar:\n        bar.set_description(f\"Epoch {epoch}\")\n        for i in bar:\n            # take a batch\n            start = i * batch_size\n            X_batch = X_train[start:start+batch_size]\n            y_batch = y_train[start:start+batch_size]\n            # forward pass\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            # backward pass\n            optimizer.zero_grad()\n            loss.backward()\n            # update weights\n            optimizer.step()\n    y_pred = model(X_test)\n    ce = loss_fn(y_pred, y_test)\n    acc = (torch.argmax(y_pred, 1) == torch.argmax(y_test, 1)).float().mean()\n    print(f\"Epoch {epoch} validation: Cross-entropy={float(ce)}, Accuracy={float(acc)}\")\n```", "```py\nimport copy\nimport tqdm\nimport numpy as np\n\nn_epochs = 200\nbatch_size = 5\nbatches_per_epoch = len(X_train) // batch_size\n\nbest_acc = - np.inf   # init to negative infinity\nbest_weights = None\ntrain_loss_hist = []\ntrain_acc_hist = []\ntest_loss_hist = []\ntest_acc_hist = []\n\nfor epoch in range(n_epochs):\n    epoch_loss = []\n    epoch_acc = []\n    # set model in training mode and run through each batch\n    model.train()\n    with tqdm.trange(batches_per_epoch, unit=\"batch\", mininterval=0) as bar:\n        bar.set_description(f\"Epoch {epoch}\")\n        for i in bar:\n            # take a batch\n            start = i * batch_size\n            X_batch = X_train[start:start+batch_size]\n            y_batch = y_train[start:start+batch_size]\n            # forward pass\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            # backward pass\n            optimizer.zero_grad()\n            loss.backward()\n            # update weights\n            optimizer.step()\n            # compute and store metrics\n            acc = (torch.argmax(y_pred, 1) == torch.argmax(y_batch, 1)).float().mean()\n            epoch_loss.append(float(loss))\n            epoch_acc.append(float(acc))\n            bar.set_postfix(\n                loss=float(loss),\n                acc=float(acc)\n            )\n    # set model in evaluation mode and run through the test set\n    model.eval()\n    y_pred = model(X_test)\n    ce = loss_fn(y_pred, y_test)\n    acc = (torch.argmax(y_pred, 1) == torch.argmax(y_test, 1)).float().mean()\n    ce = float(ce)\n    acc = float(acc)\n    train_loss_hist.append(np.mean(epoch_loss))\n    train_acc_hist.append(np.mean(epoch_acc))\n    test_loss_hist.append(ce)\n    test_acc_hist.append(acc)\n    if acc > best_acc:\n        best_acc = acc\n        best_weights = copy.deepcopy(model.state_dict())\n    print(f\"Epoch {epoch} validation: Cross-entropy={ce}, Accuracy={acc}\")\n\nmodel.load_state_dict(best_weights)\n```", "```py\nEpoch 0: 100%|█████████████████████| 21/21 [00:00<00:00, 850.82batch/s, acc=0.4, loss=1.23]\nEpoch 0 validation: Cross-entropy=1.10, Accuracy=60.0%\nEpoch 1: 100%|████████████████████| 21/21 [00:00<00:00, 3155.53batch/s, acc=0.4, loss=1.24]\nEpoch 1 validation: Cross-entropy=1.08, Accuracy=57.8%\nEpoch 2: 100%|████████████████████| 21/21 [00:00<00:00, 3489.58batch/s, acc=0.4, loss=1.24]\nEpoch 2 validation: Cross-entropy=1.07, Accuracy=60.0%\nEpoch 3: 100%|████████████████████| 21/21 [00:00<00:00, 3312.79batch/s, acc=0.4, loss=1.22]\nEpoch 3 validation: Cross-entropy=1.06, Accuracy=62.2%\n...\nEpoch 197: 100%|███████████████████| 21/21 [00:00<00:00, 3529.57batch/s, acc=1, loss=0.563]\nEpoch 197 validation: Cross-entropy=0.61, Accuracy=97.8%\nEpoch 198: 100%|███████████████████| 21/21 [00:00<00:00, 3479.10batch/s, acc=1, loss=0.563]\nEpoch 198 validation: Cross-entropy=0.61, Accuracy=97.8%\nEpoch 199: 100%|███████████████████| 21/21 [00:00<00:00, 3337.52batch/s, acc=1, loss=0.563]\nEpoch 199 validation: Cross-entropy=0.61, Accuracy=97.8%\n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.plot(train_loss_hist, label=\"train\")\nplt.plot(test_loss_hist, label=\"test\")\nplt.xlabel(\"epochs\")\nplt.ylabel(\"cross entropy\")\nplt.legend()\nplt.show()\n\nplt.plot(train_acc_hist, label=\"train\")\nplt.plot(test_acc_hist, label=\"test\")\nplt.xlabel(\"epochs\")\nplt.ylabel(\"accuracy\")\nplt.legend()\nplt.show()\n```", "```py\nimport copy\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport tqdm\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import OneHotEncoder\n\n# read data and apply one-hot encoding\ndata = pd.read_csv(\"iris.csv\", header=None)\nX = data.iloc[:, 0:4]\ny = data.iloc[:, 4:]\nohe = OneHotEncoder(handle_unknown='ignore', sparse_output=False).fit(y)\ny = ohe.transform(y)\n\n# convert pandas DataFrame (X) and numpy array (y) into PyTorch tensors\nX = torch.tensor(X.values, dtype=torch.float32)\ny = torch.tensor(y, dtype=torch.float32)\n\n# split\nX_train, X_test, y_train, y_test = train_test_split(X, y, train_size=0.7, shuffle=True)\n\nclass Multiclass(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.hidden = nn.Linear(4, 8)\n        self.act = nn.ReLU()\n        self.output = nn.Linear(8, 3)\n\n    def forward(self, x):\n        x = self.act(self.hidden(x))\n        x = self.output(x)\n        return x\n\n# loss metric and optimizer\nmodel = Multiclass()\nloss_fn = nn.CrossEntropyLoss()\noptimizer = optim.Adam(model.parameters(), lr=0.001)\n\n# prepare model and training parameters\nn_epochs = 200\nbatch_size = 5\nbatches_per_epoch = len(X_train) // batch_size\n\nbest_acc = - np.inf   # init to negative infinity\nbest_weights = None\ntrain_loss_hist = []\ntrain_acc_hist = []\ntest_loss_hist = []\ntest_acc_hist = []\n\n# training loop\nfor epoch in range(n_epochs):\n    epoch_loss = []\n    epoch_acc = []\n    # set model in training mode and run through each batch\n    model.train()\n    with tqdm.trange(batches_per_epoch, unit=\"batch\", mininterval=0) as bar:\n        bar.set_description(f\"Epoch {epoch}\")\n        for i in bar:\n            # take a batch\n            start = i * batch_size\n            X_batch = X_train[start:start+batch_size]\n            y_batch = y_train[start:start+batch_size]\n            # forward pass\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            # backward pass\n            optimizer.zero_grad()\n            loss.backward()\n            # update weights\n            optimizer.step()\n            # compute and store metrics\n            acc = (torch.argmax(y_pred, 1) == torch.argmax(y_batch, 1)).float().mean()\n            epoch_loss.append(float(loss))\n            epoch_acc.append(float(acc))\n            bar.set_postfix(\n                loss=float(loss),\n                acc=float(acc)\n            )\n    # set model in evaluation mode and run through the test set\n    model.eval()\n    y_pred = model(X_test)\n    ce = loss_fn(y_pred, y_test)\n    acc = (torch.argmax(y_pred, 1) == torch.argmax(y_test, 1)).float().mean()\n    ce = float(ce)\n    acc = float(acc)\n    train_loss_hist.append(np.mean(epoch_loss))\n    train_acc_hist.append(np.mean(epoch_acc))\n    test_loss_hist.append(ce)\n    test_acc_hist.append(acc)\n    if acc > best_acc:\n        best_acc = acc\n        best_weights = copy.deepcopy(model.state_dict())\n    print(f\"Epoch {epoch} validation: Cross-entropy={ce:.2f}, Accuracy={acc*100:.1f}%\")\n\n# Restore best model\nmodel.load_state_dict(best_weights)\n\n# Plot the loss and accuracy\nplt.plot(train_loss_hist, label=\"train\")\nplt.plot(test_loss_hist, label=\"test\")\nplt.xlabel(\"epochs\")\nplt.ylabel(\"cross entropy\")\nplt.legend()\nplt.show()\n\nplt.plot(train_acc_hist, label=\"train\")\nplt.plot(test_acc_hist, label=\"test\")\nplt.xlabel(\"epochs\")\nplt.ylabel(\"accuracy\")\nplt.legend()\nplt.show()\n```"]