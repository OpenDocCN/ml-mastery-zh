- en: Machine Learning in OpenCV (7-Day Mini-Course)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenCV 中的机器学习（7 天迷你课程）
- en: 原文：[https://machinelearningmastery.com/machine-learning-in-opencv-7-day-mini-course/](https://machinelearningmastery.com/machine-learning-in-opencv-7-day-mini-course/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://machinelearningmastery.com/machine-learning-in-opencv-7-day-mini-course/](https://machinelearningmastery.com/machine-learning-in-opencv-7-day-mini-course/)
- en: Machine learning is an amazing tool for many tasks. OpenCV is a great library
    for manipulating images. It would be great if we can put them together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习是处理许多任务的一个惊人工具。OpenCV 是一个用于图像处理的优秀库。如果我们能将它们结合起来，那就太好了。
- en: In this 7-part crash course, you will learn from examples how to make use of
    machine learning and the image processing API from OpenCV to accomplish some goals.
    This mini-course is intended for practitioners who are already comfortable with
    programming in Python, know the basic concept of machine learning, and have some
    background in manipulating images. Let’s get started.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 7 部分的速成课程中，你将通过示例学习如何利用机器学习和 OpenCV 的图像处理 API 实现一些目标。这个迷你课程是针对那些已经对 Python
    编程感到舒适、了解机器学习基本概念并有一定图像处理背景的从业人员设计的。让我们开始吧。
- en: '![](../Images/e9a40e7e62698f06dc995c46f87d7492.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/e9a40e7e62698f06dc995c46f87d7492.png)'
- en: Machine Learning in OpenCV (7-day Mini-Course)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 中的机器学习（7 天迷你课程）
- en: Photo by [Nomadic Julien](https://unsplash.com/photos/people-walking-on-street-during-daytime-uBfK5i6j1B8).
    Some rights reserved.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Nomadic Julien](https://unsplash.com/photos/people-walking-on-street-during-daytime-uBfK5i6j1B8)
    提供。保留部分权利。
- en: Who Is This Mini-Course For?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这个迷你课程适合谁？
- en: Before we get started, let’s make sure you are in the right place. The list
    below provides some general guidelines as to who this course was designed for.
    Don’t panic if you don’t match these points exactly, you might just need to brush
    up in one area or another to keep up.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们确保你在正确的地方。下面的列表提供了一些关于此课程设计对象的通用指南。如果你不完全符合这些要点，不要惊慌，你可能只需要在某个领域稍作复习以跟上课程进度。
- en: '**Developers that know how to write a little code**. This means that it is
    not a big deal for you to get things done with Python and know how to setup the
    ecosystem on your workstation (a prerequisite). It does not mean you’re a wizard
    coder, but it does mean you’re not afraid to install packages and write scripts.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会写一点代码的开发者**。这意味着你能够使用 Python 完成任务，并且知道如何在工作站上设置生态系统（这是一个先决条件）。这并不意味着你是一个代码天才，但意味着你不怕安装软件包和编写脚本。'
- en: Developers that know a little machine learning. This means you know about some
    common machine learning algorithms like regression or neural networks. It does
    not mean that you are a machine learning PhD, just that you know the landmarks
    or know where to look them up.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道一点机器学习的开发者。这意味着你了解一些常见的机器学习算法，如回归或神经网络。这并不意味着你是机器学习博士，仅仅是你知道这些领域的标志性知识或知道在哪里查找它们。
- en: '**Developers that know a bit about image processing**. This means you know
    how to read an image file, how to manipulate a pixel, and how to crop a sub-image.
    Preferably using OpenCV. It does not mean that you are an image processing expert
    but you understand that digital images are arrays of pixels.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**了解一点图像处理的开发者**。这意味着你知道如何读取图像文件，如何操作像素，以及如何裁剪子图像。最好使用 OpenCV。这并不意味着你是图像处理专家，但你理解数字图像是像素数组。'
- en: This mini-course is not a textbook on machine learning, OpenCV, or digital image
    processing. Rather, it is a project guideline that takes you step-by-step from
    a developer with minimal knowledge to a developer who can confidently use machine
    learning in OpenCV.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迷你课程不是关于机器学习、OpenCV 或数字图像处理的教科书。而是一个项目指南，逐步带你从一个具有最低限度知识的开发者成长为一个可以自信使用 OpenCV
    中的机器学习的开发者。
- en: Mini-Course Overview
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迷你课程概述
- en: This mini-course is divided into 7 parts.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迷你课程分为 7 部分。
- en: Each lesson was designed to take the average developer about 30 minutes. You
    might finish some much sooner and other you may choose to go deeper and spend
    more time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每一课的设计时间大约是 30 分钟。你可能会更快完成某些部分，也可能选择深入研究并花费更多时间。
- en: You can complete each part as quickly or as slowly as you like. A comfortable
    schedule may be to complete one lesson per day over seven days. Highly recommended.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据自己的节奏完成每个部分。一个舒适的时间表可能是每隔一天完成一节课，共七天。强烈推荐。
- en: 'The topics you will cover over the next 7 lessons are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的 7 节课中你将涵盖的主题如下：
- en: '**Lesson 1**: Introduction to OpenCV'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 1 课**：OpenCV 介绍'
- en: '**Lesson 2**: Read and Display Images Using OpenCV'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 2 课**：使用 OpenCV 读取和显示图像'
- en: '**Lesson 3**: Finding Circles'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第 3 课**：寻找圆形'
- en: '**Lesson 4**: Extracting Subimages'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**课程 4**：提取子图像'
- en: '**Lesson 5**: Matching Pennies'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**课程 5**：匹配硬币'
- en: '**Lesson 6**: Building a Coin Classifier'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**课程 6**：构建硬币分类器'
- en: '**Lesson 7**: Using DNN Module in OpenCV'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**课程 7**：在 OpenCV 中使用 DNN 模块'
- en: This is going to be a lot of fun.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会非常有趣。
- en: You’re going to have to do some work though, a little reading, a little research
    and a little programming. You want to learn machine learning and computer vision
    right?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不过你需要做一些工作，包括阅读、研究和编程。你想学习机器学习和计算机视觉，对吗？
- en: '**Post your results in the comments**; I’ll cheer you on!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**在评论中发布你的结果**；我会为你加油！'
- en: Hang in there; don’t give up.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 坚持下去；不要放弃。
- en: 'Lesson 01: Introduction to OpenCV'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程 01：OpenCV 简介
- en: OpenCV is a popular open source library for processing images. It has API bindings
    in Python, C++, Java, and Matlab. It comes with thousands of functions and implemented
    many advanced image processing algorithms. If you’re using Python, a common alternative
    to OpenCV is PIL (Python Imaging Library, or its successor, Pillow). Compared
    to PIL, OpenCV has a richer set of features and is often faster because it is
    implemented in C++.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 是一个流行的开源图像处理库。它在 Python、C++、Java 和 Matlab 中都有 API 绑定。它提供了数千个函数，并实现了许多先进的图像处理算法。如果你使用
    Python，OpenCV 的一个常见替代品是 PIL（Python Imaging Library，或其继任者 Pillow）。与 PIL 相比，OpenCV
    提供了更丰富的功能集，并且通常速度更快，因为它是用 C++ 实现的。
- en: This mini-course is to apply machine learning in OpenCV. In later lessons of
    this mini-course, you will also need TensorFlow/Keras and tf2onnx library in Python.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迷你课程是为了在 OpenCV 中应用机器学习。在本课程的后续课程中，你还需要 TensorFlow/Keras 和 Python 中的 tf2onnx
    库。
- en: In this lesson your goal is to install OpenCV.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，你的目标是安装 OpenCV。
- en: 'For a basic Python environment, you can install packages using `pip`. To install
    OpenCV using `pip`, together with TensorFlow and tf2onnx, you can use:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基础的 Python 环境，你可以使用 `pip` 安装软件包。要使用 `pip` 安装 OpenCV、TensorFlow 和 tf2onnx，你可以使用：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'OpenCV is named as package `opencv-python` in PyPI, but it contains only the
    “free” algorithms and main modules. There is also the package `opencv-contrib-python`,
    which also included the “extra” modules. These extra modules are less stable and
    not well-tested. If you prefer to install the latter, you should use the following
    commmand instead:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 在 PyPI 中被称为 `opencv-python` 包，但它仅包含“免费”算法和主要模块。还有一个名为 `opencv-contrib-python`
    的包，其中包含了“额外”模块。这些额外的模块较不稳定且未经充分测试。如果你更愿意安装后者，你应该使用以下命令：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, if you’re using Anaconda or miniconda environment, the name of the
    package is just `opencv`, which you can install with the command `conda install`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用 Anaconda 或 miniconda 环境，软件包的名称仅为 `opencv`，你可以使用 `conda install` 命令进行安装。
- en: 'To know your OpenCV installation works, you can simply run a simple script
    and check its version:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你的 OpenCV 安装是否正常工作，你可以简单地运行一个小脚本并检查其版本：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Learn more about OpenCV, you can start with its [online documentation](https://docs.opencv.org/4.x/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于 OpenCV 的信息，你可以从其 [在线文档](https://docs.opencv.org/4.x/) 开始。
- en: Your Task
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: Repeat the above code to make sure you have OpenCV correctly installed. Can
    you also print the version of TensorFlow module by adding a few lines to the code?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上述代码，以确保你已正确安装 OpenCV。你能通过在代码中添加几行来打印 TensorFlow 模块的版本吗？
- en: In the next lesson, you will use OpenCV to read and display an image.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，你将使用 OpenCV 读取和显示图像。
- en: 'Lesson 02: Read and Display Image Using OpenCV'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程 02：使用 OpenCV 读取和显示图像
- en: 'OpenCV, the Open Source Computer Vision Library, is a powerful tool for image
    processing and computer vision tasks. But before diving into complex algorithms,
    let’s master the basics: reading and displaying images.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV，即开源计算机视觉库，是一个强大的图像处理和计算机视觉任务工具。但在深入复杂算法之前，让我们先掌握基础：读取和显示图像。
- en: 'Reading an image using OpenCV is to use `cv2.imread()` function. It takes the
    path to the image file and returns a NumPy array. The array would usually be three-dimensional,
    in height×width×channel and each element is an unsigned 8-bit integer. “Channel”
    is usually BGR (blue-green-red) in OpenCV. But if you prefer to load the image
    in grayscale, you can add an extra parameter, such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 读取图像是使用 `cv2.imread()` 函数。它接受图像文件的路径并返回一个 NumPy 数组。这个数组通常是三维的，形状为高度×宽度×通道，每个元素是无符号
    8 位整数。在 OpenCV 中，“通道”通常是 BGR（蓝-绿-红）。但如果你更愿意以灰度图像加载，你可以添加一个额外的参数，如：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code above will print the array dimension. While we usually describe an
    image as width×height, array dimension is described as height×width. If the image
    is read in grayscale, there is only one channel and hence the output will be a
    two-dimensional array.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将打印数组的维度。虽然我们通常将图像描述为宽度×高度，但数组维度描述为高度×宽度。如果图像以灰度形式读取，则只有一个通道，因此输出将是一个二维数组。
- en: If you removed the second argument to make it simply `cv2.imread("path/filename.jpg")`,
    the array should be in shape height×width×3 for three channels of BGR.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移除了第二个参数，使其仅为 `cv2.imread("path/filename.jpg")`，则数组的形状应为高度×宽度×3，表示 BGR 的三个通道。
- en: 'To display an image, you can use OpenCV’s `cv2.imshow()` function. This will
    create a window to display the image. But this window will not be shown unless
    you ask OpenCV to wait for you to interact with the window. Normally, you use:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示图像，可以使用 OpenCV 的 `cv2.imshow()` 函数。这将创建一个窗口来显示图像。但是，除非你要求 OpenCV 等待你与窗口互动，否则此窗口将不会显示。通常，你可以使用：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `cv2.imshow()` takes the window title as its first argument. The image to
    display should be in BGR channel order. The `cv2.waitKey()` function will wait
    for your key press for certain milliseconds as specified in its function argument.
    If zero, it will wait indefinitely. The key press will be returned as its codepoint
    in integer, which in this case, you ignored it. As a good practice, you closed
    the window before this program ends.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`cv2.imshow()` 将窗口标题作为第一个参数。要显示的图像应为 BGR 通道顺序。`cv2.waitKey()` 函数将等待你按键的时间为函数参数中指定的毫秒数。如果为零，它将无限期等待。按键将以整数形式返回其代码点，在这种情况下，你可以忽略它。作为一个好的做法，你应该在程序结束前关闭窗口。'
- en: 'Putting it all together:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容组合起来：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your Task
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: 'Modify the code above to point the path to an image in your disk and try it
    out. How can you modify the code above to wait until Esc key is pressed but ignoring
    all other keys? (Hint: The code point for Esc key is 27)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 修改上面的代码，将路径指向你磁盘中的一张图像并试一下。你如何修改上面的代码以等待 Esc 键被按下，但忽略所有其他按键？（提示：Esc 键的代码点是 27）
- en: In the next lesson, you will see how to find patterns in an image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，你将看到如何在图像中寻找模式。
- en: 'Lesson 03: Finding Circles'
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程 03：寻找圆形
- en: Since a digital image is represented as a matrix, you can devise your algorithm
    and check each pixel of the image to identify if some pattern exists in the image.
    Over the years, a lot of clever algorithms have been invented and you can learn
    some of them in any digital image processing textbook.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数字图像表示为矩阵，你可以设计你的算法并检查图像的每个像素以识别图像中是否存在某种模式。多年来，发明了许多巧妙的算法，你可以在任何数字图像处理教科书中学习其中的一些。
- en: 'In this mini-course, you’re going to solve a simple problem: Given an image
    with many coins, identify and count a particular type of coin. Coins are circles.
    To identify circles in an image, one promising algorithm is to use the Hough Circle
    Transform.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个迷你课程中，你将解决一个简单的问题：给定一张包含许多硬币的图像，识别并计数某种特定类型的硬币。硬币是圆形的。要识别图像中的圆形，一种有前景的算法是使用霍夫圆变换。
- en: 'Hough Transform is an algorithm that makes use of **gradient** information
    of an image. Therefore, it works on a grayscale image rather than a color image.
    To convert a colored image to grayscale, you can use the `cv2.cvtColor()` function
    from OpenCV. Because Hough Transform is based on gradient information, it would
    be sensitive to image noise. Applying Gaussian blur is a usual preprocessing step
    to reduce noise for Hough Transform. In code, you apply the following for a BGR
    image you read:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 霍夫变换是一种利用图像的**梯度**信息的算法。因此，它作用于灰度图像而不是彩色图像。要将彩色图像转换为灰度图像，你可以使用 OpenCV 的 `cv2.cvtColor()`
    函数。由于霍夫变换基于梯度信息，它对图像噪声非常敏感。应用高斯模糊是一个常见的预处理步骤，用于减少霍夫变换的噪声。在代码中，对于你读取的 BGR 图像，你可以应用以下操作：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here the Gaussian blur is applied using a $25\times 25$ kernel. You can use
    a smaller or larger kernel depending on the level of noise in the image.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用 $25\times 25$ 的内核应用高斯模糊。根据图像中的噪声水平，你可以使用较小或较大的内核。
- en: 'Hough Circle Transform is to find circles from an image, using the following
    function:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 霍夫圆变换用于从图像中寻找圆，使用以下函数：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are a lot of parameters. The first argument is the grayscale image and
    the second is the algorithm to use. The rest are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多参数。第一个参数是灰度图像，第二个参数是要使用的算法。其余的参数如下：
- en: '`dp`: Ratio of image resolution to accumulator resolution. Use 1.0 to 2.0 normally.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dp`：图像分辨率与累加器分辨率的比例。通常使用 1.0 到 2.0。'
- en: '`minDist`: Minimum distance between centers of detected circles. The lesser
    the value, the more false positives you will get.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minDist`：检测到的圆心之间的最小距离。值越小，假阳性越多。'
- en: '`param1` This is the threshold for the Canny edge detector'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`param1` 这是 Canny 边缘检测器的阈值'
- en: '`param2`: When algorithm `cv2.HOUGH_GRADIENT` is used, this is the accumulator
    threshold. The lesser the value, the more false positives.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`param2`：当使用算法 `cv2.HOUGH_GRADIENT` 时，这是累加器阈值。值越小，假阳性越多。'
- en: '`minRadius` and `maxRadius`: Minimum and maximum circle radius to detect'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minRadius` 和 `maxRadius`：检测的最小和最大圆半径'
- en: The returned value from the function `cv2.HoughCircles()` is a NumPy array of
    circles, represented as rows containing the center coordinates and the radius.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `cv2.HoughCircles()` 函数返回的值是一个 NumPy 数组，表示为包含中心坐标和半径的行。
- en: 'Let’s try with [a sample image](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-1.jpg):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试 [一个示例图像](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-1.jpg)：
- en: '[![](../Images/6f23bf7232a246ffa58793c4cdf96a35.png)](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-1.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![](../Images/6f23bf7232a246ffa58793c4cdf96a35.png)](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-1.jpg)'
- en: Coins
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 硬币
- en: 'Download the image, save it as `coins-1.jpg`, and run the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下载图像，保存为 `coins-1.jpg`，并运行以下代码：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](../Images/2b42283093765e74280c9447a37dfed3.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/2b42283093765e74280c9447a37dfed3.png)'
- en: Detected circles in blue with centers in red
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检测到的圆用蓝色表示，圆心用红色标出
- en: The code above first rounded off and converted the detected circle data into
    integers. Then draw the circles on the original image accordingly. From the illustration
    above, you can see how well the Hough Circle Transform helps you find the coins
    in the image.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码首先将检测到的圆数据四舍五入并转换为整数。然后在原始图像上绘制这些圆。从上面的示例中，你可以看到霍夫圆变换如何帮助你找到图像中的硬币。
- en: Further Readings
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'P. E. Hart. “How the Hough Transform was Invented”. IEEE Signal Processing
    Magazine, 26(6), Nov. 2009, pp. 18–22\. DOI: 10.1109/msp.2009.934181.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'P. E. Hart. “霍夫变换的发明”。IEEE 信号处理杂志，26(6)，2009年11月，第18–22页。DOI: 10.1109/msp.2009.934181。'
- en: 'R. O. Duda and P. E. Hart. “Use of the Hough Transformation to Detect Lines
    and Curves in Pictures”. Comm. ACM, 15, Jan. 11–15\. DOI: 10.1145/361237.361242.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'R. O. Duda 和 P. E. Hart. “使用霍夫变换检测图像中的直线和曲线”。通讯 ACM，15，1月 11–15。DOI: 10.1145/361237.361242。'
- en: Your Task
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: The detection is sensitive to the parameters you provided to \codetext{cv2.HoughCircles()}
    function. Try to modify the parameters and see how it results. You can also try
    to find the best parameters for a different picture, especially one with different
    lighting conditions or different resolutions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 检测对你提供给 `cv2.HoughCircles()` 函数的参数非常敏感。尝试修改参数并查看结果。你也可以尝试为不同的图片找到最佳参数，尤其是不同光照条件或不同分辨率的图片。
- en: In the next lesson, you will see how you can extract coins from the image based
    on the detected circles.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到如何根据检测到的圆从图像中提取硬币。
- en: 'Lesson 04: Extracting Subimages'
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第04课：提取子图像
- en: 'The image you read using OpenCV is a NumPy array of shape height×width×channel.
    To extract part of the image, you can simply use the NumPy slicing syntax. For
    example, from a BGR colored image, you can extract the red channel with:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 读取的图像是一个形状为高度×宽度×通道的 NumPy 数组。要提取图像的一部分，你可以简单地使用 NumPy 切片语法。例如，从 BGR
    彩色图像中，你可以用以下代码提取红色通道：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Therefore, to extract part of an image, you can use
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要提取图像的一部分，你可以使用
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: which you will get a rectangular portion of a larger image. Remember that in
    matrices, you first count the vertical elements (pixels) from top to bottom, then
    count the horizontal from left to right. Hence you should describe the $y$-coordinate
    range first in the slicing syntax.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你会得到较大图像的一个矩形部分。请记住，在矩阵中，你首先从上到下计算垂直元素（像素），然后从左到右计算水平元素。因此，你应在切片语法中首先描述 $y$-坐标范围。
- en: 'Let’s modify the code in the previous lesson, to extract each coin we found:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改前一节中的代码，提取我们找到的每个硬币：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code extracts a square subimage for each circle the Hough Transform found.
    Then the subimage is displayed in a window and wait for your key until the next
    one is displayed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码为霍夫变换找到的每个圆提取一个正方形子图像。然后在窗口中显示该子图像，并等待你按键后再显示下一个。
- en: '![](../Images/270da6ee70892a159503a892bffba9d8.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/270da6ee70892a159503a892bffba9d8.png)'
- en: OpenCV window showing a detected coin
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV 窗口显示检测到的硬币
- en: Your Task
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: Run this code. You will notice that each circle detected may be of a different
    size so are the subimages extracted. How can you resize the subimages to a consistent
    size before displaying them in the window?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码。你会发现每个检测到的圆圈可能大小不同，提取的子图像也是如此。在显示它们之前，你如何将子图像调整为一致的大小？
- en: In the next lesson, you will learn to compare the extracted subimages to a reference
    image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，你将学习如何将提取的子图像与参考图像进行比较。
- en: 'Lesson 05: Matching Pennies'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课时 05：匹配硬币
- en: Our task is to identify and count the penny coins from an image. You can find
    the [image of a U.S. penny from Wikipedia.](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Lincoln-Cent-Reverse-sheild.png/240px-Lincoln-Cent-Reverse-sheild.png)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是从图像中识别并计数便士硬币。你可以在[维基百科上找到美国便士的图像。](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Lincoln-Cent-Reverse-sheild.png/240px-Lincoln-Cent-Reverse-sheild.png)
- en: With this as the reference image, how can you compare the identified coin with
    the reference? This is a problem more difficult than it sounds. Used coins can
    be rusty, dull, or with scratches. The coins in the picture can be rotated. It
    is not easy to compare pixels and tell if they are the same coin.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以此为参考图像，如何将识别出的硬币与参考图像进行比较？这比听起来更复杂。使用过的硬币可能会生锈、暗淡或有划痕。图片中的硬币可能会旋转。比较像素并判断它们是否为同一硬币并不容易。
- en: 'A better way is to use keypoint matching algorithms. There are several keypoint
    algorithms in OpenCV. Let’s try with the ORB, which is an invention from the OpenCV
    team. Downloading the reference image from the link above as `penny.png`, you
    can extract keypoints and keypoint descriptors with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用关键点匹配算法。OpenCV中有几种关键点算法。我们来尝试使用ORB，它是OpenCV团队的一个发明。从上述链接下载参考图像为`penny.png`，你可以使用以下代码提取关键点和关键点描述符：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The tuple `kp` are keypoint objects, but not as important as the `ref_desc`
    array, which is the **keypoint descriptors**. This is a NumPy array with shape
    $K\times 32$ for $K$ keypoints detected. Each keypoint’s ORB descriptor is a vector
    of 32 integers.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 元组`kp`是关键点对象，但不像`ref_desc`数组那样重要，后者是**关键点描述符**。这是一个形状为$K\times 32$的NumPy数组，其中$K$为检测到的关键点数。每个关键点的ORB描述符是一个32个整数的向量。
- en: 'If you get the descriptor from another image, you can compare it to see if
    any keypoints match. You should not expect an exact match in descriptors. Instead,
    you can apply the [**Lowe’s ratio test**](https://stackoverflow.com/questions/51197091/)
    to decide if the keypoints are matched:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从另一张图像中获取描述符，你可以将其与已有的描述符进行比较。你不应该期望描述符完全匹配。相反，你可以应用[**Lowe比率测试**](https://stackoverflow.com/questions/51197091/)来决定关键点是否匹配：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you use a brute-force matcher from `cv2.BFMatcher()` to run the kNN algorithm
    to get the two nearest neighbors from each reference keypoint to the keypoints
    from the candidate image. The vector distance is then compared (such that a shorter
    distance means a better match). The Lowe’s ratio test is to tell if the match
    is good enough. You may try a different constant than 0.8 above. We count the
    number of good matches, which we will claim the coin is identified if enough good
    match is found.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用`cv2.BFMatcher()`的蛮力匹配器运行kNN算法，以获取每个参考关键点到候选图像中关键点的两个最近邻。然后比较向量距离（距离较短表示匹配较好）。Lowe比率测试用于判断匹配是否足够好。你可以尝试不同于0.8的常数。我们计算良好匹配的数量，如果找到足够的良好匹配，我们就认为硬币被识别出来了。
- en: Below is the full code, which we will show and identify each coin found using
    Matplotlib. Since Matplotlib expects a colored image in RGB channels instead of
    BGR channels, you need to convert the image using `cv2.cvtColor()` before displaying
    it with `plt.imshow()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码，我们将使用Matplotlib显示并识别每个找到的硬币。由于Matplotlib期望的是RGB通道的彩色图像而不是BGR通道，你需要在使用`plt.imshow()`显示图像之前，使用`cv2.cvtColor()`将图像转换为RGB。
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](../Images/79dcb6d1ab1c805135ec1de815afb83d.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/79dcb6d1ab1c805135ec1de815afb83d.png)'
- en: Detected coins and the number of keypoints matched
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检测到的硬币和匹配的关键点数量
- en: You can see that the number of keypoints matched cannot provide a clear metric
    to help identify penny coins from other coins. Can you think of other algorithm
    other than kNN that might be helpful?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，匹配的关键点数量无法提供一个明确的度量来帮助识别便士硬币与其他硬币。你能想到其他可能有用的算法吗？
- en: Further Readings
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '[Feature Matching. OpenCV.](https://docs.opencv.org/3.4/dc/dc3/tutorial_py_matcher.html)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[特征匹配。OpenCV。](https://docs.opencv.org/3.4/dc/dc3/tutorial_py_matcher.html)'
- en: '[How does the Lowe’s ratio test work? Stack Overflow.](https://stackoverflow.com/questions/51197091/how-does-the-lowes-ratio-test-work)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Lowe 的比率测试是如何工作的？Stack Overflow。](https://stackoverflow.com/questions/51197091/how-does-the-lowes-ratio-test-work)'
- en: Your Task
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: The code above uses ORB keypoints. You can also try with SIFT keypoints. How
    to modify the code above? Would you see the change in the number of keypoints
    matched? Also, since ORB features are vectors. Can you build a logistic regression
    classifier to identify good keypoints such that you do not need to rely on a reference
    image?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用了 ORB 关键点。你也可以尝试使用 SIFT 关键点。如何修改上面的代码？你会看到关键点匹配数量的变化吗？另外，由于 ORB 特征是向量。你能构建一个逻辑回归分类器来识别好的关键点，从而不需要依赖参考图像吗？
- en: In the next lesson, you will work on a better coin identifier.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节课中，你将处理一个更好的硬币识别器。
- en: 'Lesson 06: Building a Coin Classifier'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 课程 06：构建一个硬币分类器
- en: Provided with an image of a coin and identifying if it is a U.S. penny coin
    is easy for humans but not so for computers. It is known that the best way to
    do such classification is by machine learning. You should first extract feature
    vectors from the image, then run a machine learning algorithm as a classifier
    to tell if it is a match or not.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一枚硬币的图像并确定它是否为美国便士硬币，对人类来说很容易，但对计算机来说却不那么简单。已知进行这种分类的最佳方法是使用机器学习。你应该首先从图像中提取特征向量，然后运行机器学习算法作为分类器，以判断它是否匹配。
- en: Deciding which feature to use is a hard problem itself. But if you use the convolutional
    neural network, you can let the machine learning algorithm figure out the features
    by itself. But to train a neural network, you need data. Fortunately, you don’t
    need a lot. Let’s see how you can build one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪种特征本身就是一个困难的问题。但是如果你使用卷积神经网络，你可以让机器学习算法自动找出特征。然而，训练神经网络需要数据。幸运的是，你不需要很多数据。让我们看看你如何构建一个。
- en: 'Firstly, you can get a picture of some coins here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以在这里查看一些硬币的图片：
- en: '[https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-2.jpg](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-2.jpg)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-2.jpg](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-2.jpg)'
- en: '[https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-3.jpg](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-3.jpg)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-3.jpg](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-3.jpg)'
- en: '![](../Images/3fa52e51d85e30572209207a0015d874.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3fa52e51d85e30572209207a0015d874.png)'
- en: Picture of coins to be extracted as dataset to train a neural network
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取的硬币图片作为数据集用于训练神经网络
- en: 'Save them as `coins-2.jpg` and `coins-3.jpg`, then extract the images of coins,
    using Hough Circle Transform, and save them into a directory `dataset`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们保存为`coins-2.jpg`和`coins-3.jpg`，然后使用霍夫圆变换提取硬币的图像，并将它们保存到一个名为`dataset`的目录中：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are not many images. You can manually tag each image as a penny coin (positive)
    or not (negative). One way is to move the positive samples into the sub-directory
    `dataset/pos` and the negative samples into `dataset/neg`. For your convenience,
    you can find a copy of tagged images in the zip file [here](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins.zip).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图像数量不多。你可以手动将每张图像标记为便士硬币（正样本）或非便士硬币（负样本）。一种方法是将正样本移动到子目录`dataset/pos`中，将负样本移动到`dataset/neg`中。为了方便你，你可以在[这里](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins.zip)找到标记过的图像的压缩文件副本。
- en: With these, let’s build a convolutional neural network for this binary classification
    problem, using Keras and TensorFlow.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们来构建一个卷积神经网络来解决这个二分类问题，使用 Keras 和 TensorFlow。
- en: During the data preparation phase, you will read each positive and negative
    image sample. To make the convolutional neural network simpler, you fixed the
    input size to $256\times 256$ pixels by resizing the image first. To increase
    variations in the dataset, you can rotate each image by 90, 180, and 270 degrees
    and add to the dataset (it is easy since the image samples are all square). Then,
    you can make use of the `train_test_split()` function from scikit-learn to separate
    the dataset into training and test sets in a ratio of 7:3.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据准备阶段，你将读取每个正样本和负样本图像。为了简化卷积神经网络，你将输入大小固定为$256\times 256$像素，通过先调整图像大小来实现。为了增加数据集的变化性，你可以将每张图像旋转90度、180度和270度，并将其添加到数据集中（因为图像样本都是正方形的，这很简单）。然后，你可以利用
    scikit-learn 中的`train_test_split()`函数将数据集分为训练集和测试集，比例为7:3。
- en: To create the model, you can use the classific architecture of multiple Conv2D
    layers with MaxPooling, then followed by Dense layers at the output. Note that
    it is a binary classification model. Hence at the final output layer, you should
    use sigmoid activation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建模型，你可以使用多个Conv2D层和MaxPooling的分类架构，然后在输出层后跟Dense层。请注意这是一个二分类模型。因此，在最终输出层，你应该使用sigmoid激活函数。
- en: 'At training, you can simply use a large number of iterations (e.g., `epochs=200`)
    with early stopping so you don’t need to worry about underfitting. You should
    monitor for the loss evaluated at the test set to be sure not to run into overfitting.
    In code, this is how you can train a model and save the model as `penny.h5`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在训练时，你可以简单地使用大量的迭代（例如，`epochs=200`）并设置早期停止，以避免担心过拟合。你应该监控在测试集上评估的损失，以确保不会出现过拟合。在代码中，你可以这样训练模型并将其保存为`penny.h5`：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Observe its output, you should easily see the accuracy reach above 90% with
    not many iterations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 观察其输出，你应该很容易看到准确率在几次迭代后超过90%。
- en: Your Task
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: Run the code above and create a trained model in `penny.h5`, which you will
    use in the next lesson.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码并创建一个训练好的模型`penny.h5`，你将在下一课中使用它。
- en: 'You can modify the model design and see if you can improve the accuracy. Some
    ideas you can try are: using a different number of Conv2D-MaxPooling layers, different
    sizes of each layer other than 16-32-64-128 above, or using an activation function
    other than ReLU.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改模型设计，看看是否能提高准确率。你可以尝试的一些想法包括：使用不同数量的Conv2D-MaxPooling层、不同的层大小（例如16-32-64-128），或使用ReLU以外的激活函数。
- en: In the next lesson, you will convert the model you created in Keras to use in
    OpenCV.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，你将把你在Keras中创建的模型转换为OpenCV使用的格式。
- en: 'Lesson 07: Using DNN Module in OpenCV'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第07课：在OpenCV中使用DNN模块
- en: 'Given you have built a convolutional neural network in the previous lesson,
    you can now use it together with OpenCV. It is easier for OpenCV to consume your
    model if you first convert it into ONNX format. To do so, you would need the tf2onnx
    module from Python. Once you installed it, you can convert the model with the
    following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在上一课中已经构建了一个卷积神经网络，你现在可以将其与OpenCV一起使用。如果你首先将其转换为ONNX格式，OpenCV会更容易使用你的模型。为此，你需要Python的tf2onnx模块。安装完成后，你可以使用以下命令转换模型：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you saved your Keras model as `penny.h5`, this command will create the file
    `penny.onnx`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你将Keras模型保存为`penny.h5`，此命令将创建文件`penny.onnx`。
- en: 'With the ONNX model file, you can now use the `cv2.dnn` module from OpenCV.
    The usage is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ONNX模型文件，你现在可以使用OpenCV的`cv2.dnn`模块。使用方法如下：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That is, you create a neural network object with OpenCV, assign the input, and
    run the model with `forward()` to fetch the output, which according to how you
    designed your model, is a floating point value between 0 and 1\. As a convention
    in neural networks, the input is **batched** even if you provide only one input
    sample. Hence you should add a batch dimension to the images before sending them
    to the neural network.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你使用OpenCV创建一个神经网络对象，分配输入，并使用`forward()`运行模型以获取输出，这个输出是0到1之间的浮点值，具体取决于你设计模型的方式。作为神经网络的惯例，即使你只提供一个输入样本，输入也是**批处理**的。因此，在将图像发送到神经网络之前，你应该为图像添加一个批处理维度。
- en: 'Now let’s see how you can achieve the goal of counting pennies. You can start
    by modifying the code from Lesson 05, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何实现硬币计数的目标。你可以从修改第05课的代码开始，如下所示：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Instead of using ORB and counting the good keypoints for a match, you used
    the convolutional neural network to read the sigmoidal output. The output is as
    follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了卷积神经网络来读取sigmoidal输出，而不是使用ORB并计算匹配的好关键点。输出如下：
- en: '![](../Images/771be27b59b976bf3e3a956b4f503330.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/771be27b59b976bf3e3a956b4f503330.png)'
- en: Detected coins and the match score by the neural network
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 神经网络检测到的硬币及其匹配得分
- en: 'You can see quite good a result with this model. All the pennies are identified
    with a score close to 1\. The negative samples are not as good (probably because
    we did not provide enough negative samples). Let’s use 0.9 as the score cut-off
    value and rewrite the program to give a count:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个模型的效果相当好。所有硬币都被识别，得分接近1。负样本效果不如预期（可能是因为我们提供的负样本不够）。让我们使用0.9作为得分截断值，并重写程序以进行计数：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Your Task
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你的任务
- en: 'Run the above code to test it out. You can try it with another picture like
    this one:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码进行测试。你可以尝试使用另一张图片，如下所示：
- en: '[https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-4.jpg](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-4.jpg)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-4.jpg](https://machinelearningmastery.com/wp-content/uploads/2024/01/coins-4.jpg)'
- en: Can you modify the code above to report the count by reading images continuously
    from your webcam?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你能修改上面的代码，通过不断从你的摄像头读取图像来报告计数吗？
- en: This was the final lesson.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一节课。
- en: The End! (*Look How Far You Have Come*)
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完结！（*看看你走了多远*)
- en: You made it. Well done!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了，干得好！
- en: Take a moment and look back at how far you have come.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间回顾一下你走了多远。
- en: You discovered OpenCV as a machine learning library in addition to its image
    processing capabilities.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你发现了 OpenCV 作为一个机器学习库，除了其图像处理能力之外。
- en: You made use of OpenCV to extract image features as numerical vectors, which
    is the basis for any machine learning algorithm.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你利用 OpenCV 提取图像特征作为数值向量，这是任何机器学习算法的基础。
- en: You built a neural network model and converted it to use with OpenCV.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你构建了一个神经网络模型，并将其转换为与 OpenCV 兼容。
- en: Finally, you build a penny counter program. While not perfect, it demonstrates
    how you can combine OpenCV with machine learning.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你构建了一个硬币计数程序。虽然不完美，但它展示了如何将 OpenCV 与机器学习结合起来。
- en: Don’t make light of this, you have come a long way in a short amount of time.
    This is just the beginning of your computer vision journey with machine learning.
    Keep practicing and developing your skills.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不要轻视这一点，你在短时间内取得了长足的进步。这只是你计算机视觉和机器学习之旅的开始。继续练习和提升你的技能。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: '**How did you do with the mini-course?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**你在这个迷你课程中的表现如何？**'
- en: Did you enjoy this crash course?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你喜欢这个速成课程吗？
- en: '**Do you have any questions? Were there any sticking points?**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**你有任何问题吗？有没有什么难点？**'
- en: Let me know. Leave a comment below.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉我。请在下方留言。
