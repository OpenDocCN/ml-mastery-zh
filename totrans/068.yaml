- en: Extracting Histogram of Gradients with OpenCV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://machinelearningmastery.com/opencv_hog/](https://machinelearningmastery.com/opencv_hog/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Besides the feature descriptor generated by SIFT, SURF, and ORB, as in the [previous
    post](https://machinelearningmastery.com/opencv_sift_surf_orb_keypoints/), the
    Histogram of Oriented Gradients (HOG) is another feature descriptor you can obtain
    using OpenCV. HOG is a robust feature descriptor widely used in computer vision
    and image processing for object detection and recognition tasks. It captures the
    distribution of gradient orientations in an image and provides a powerful representation
    invariant to changes in illumination and shadowing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this post, you will learn about HOG. Specifically, you will know:'
  prefs: []
  type: TYPE_NORMAL
- en: What is HOG, and how is it related to an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to compute it in OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kick-start your project** with my book [Machine Learning in OpenCV](https://machinelearning.samcart.com/products/machine-learning-opencv/).
    It provides **self-study tutorials** with **working code**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.![](../Images/efd0e8bb6d4b7717c9992295caca3847.png)
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Histogram of Gradients with OpenCV
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Alexas_Fotos](https://unsplash.com/photos/white-and-black-piglet-on-gray-rocky-ground-during-daytime-A0qtF_zwx_M).
    Some rights reserved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This post is divided into two parts; they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HOG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computing HOG in OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HOg for People Detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding HOG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept behind the HOG algorithm is to compute the distribution of gradient
    orientations in localized portions of an image. HOG operates on a **window**,
    which is a region of fixed pixel size on the image. A window is divided into small
    spatial regions, known as a **block**, and a block is further divided into multiple
    **cells**. HOG calculates the gradient magnitude and orientation within each cell,
    and creates a histogram of gradient orientations. Then the histograms within the
    same block are concatenated.
  prefs: []
  type: TYPE_NORMAL
- en: Gradient measures how a pixel’s color intensity compares to its neighbors. The
    more drastic it changes, the higher the magnitude. The orientation tells which
    direction is the steepest gradient. Usually, this is applied on a single-channel
    image (i.e., grayscale), and each pixel can have its own gradient. HOG gathers
    all gradients from a block and puts them into a histogram.
  prefs: []
  type: TYPE_NORMAL
- en: The clever way of making a histogram in HOG is that the bins in a histogram
    are determined by the angle, but the value is interpolated between the closest
    bins. For example, if the bins are assigned values 0, 20, 40, and so on while
    the gradient was 10 at angle 30, a value of 5 was added to bins of 20 and 40\.
    This way, HOG can effectively capture the texture and shape of objects within
    the image.
  prefs: []
  type: TYPE_NORMAL
- en: HOG is particularly effective for detecting objects with distinguishable textures
    and patterns, making it a popular choice for tasks such as pedestrian detection
    and other forms of object recognition. With its ability to capture the distribution
    of gradient orientations, HOG provides a robust representation invariant to variations
    in lighting conditions and shadows.
  prefs: []
  type: TYPE_NORMAL
- en: Computing HOG in OpenCV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenCV provides a straightforward method to compute the HOG descriptor, making
    it easily accessible for developers and researchers. Let’s take a look at a basic
    example of how to compute HOG in OpenCV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'HOG computes features for one window at a time. There are multiple blocks in
    a window. In a block, there are multiple “cells”. See the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/1d790511493f51137f98e042930365d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Assume this entire picture is one window. A window is divided into cells (green
    grids), and several cells are combined into one block (red and blue boxes). There
    are many overlapping blocks in one window, but all blocks are the same size.
  prefs: []
  type: TYPE_NORMAL
- en: Each cell is of a fixed size. In the above, you used 64×64 pixels in a cell.
    Each block has an equal number of cells. In the above, you used 4×4 cells in a
    block. Also, there is equal number of cells in a window; you used 8×6 cells above.
    However, we are not dividing an image into blocks or windows when we compute HOG.
    But instead,
  prefs: []
  type: TYPE_NORMAL
- en: Consider a window as a sliding window on the image, in which the sliding window’s
    stride size is the size of one cell, i.e., it slides across one cell at a time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We divide the window into cells of fixed size
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We set up the second sliding window that matches the block size and scan the
    window. It slides across one cell at a time
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within a block, HOG is computed from each cell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The returned HOG is a vector for the entire image. In the code above, you reshaped
    it to make it clear the hierarchy of windows, blocks, cells, and histogram bins.
    For example, `hog_feats[i][j]` corresponds to the window (in numpy slicing syntax):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Or, equivalently, the window with the cell (i,j) at the top left corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sliding window is a common technique in object detection because you cannot
    be sure a particular object lies exactly in a grid cell. Making smaller cells
    but larger windows is a better way to catch the object than just seeing a part
    of it. However, there’s a limitation: An object larger than the window will be
    missed. Also, an object too small may be dwarfed by other elements in the window.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, you have some downstream tasks associated with HOG, such as running
    an SVM classifier on the HOG features for object detection. In this case, you
    may want to reshape the HOG output into vectors of the entire block rather than
    in the hierarchy of each cell like above.
  prefs: []
  type: TYPE_NORMAL
- en: Using HOG for People Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature extraction technique in the code above is useful if you want to
    get the raw feature vectors for other purposes. But for some common tasks, OpenCV
    comes with pre-trained machine learning models for your disposal without much
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the photo from the following URL (save it as `people.jpg`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY](https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/972495e14bef2bf7369802e8639f76ea.png)'
  prefs: []
  type: TYPE_IMG
- en: A photo is used as an example to detect people using HOG.
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [Chris Dickens](https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY).
    Some rights reserved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a picture of people crossing a street. OpenCV has a “people detector”
    in HOG that was trained on a 64×128 pixel window size. Using it to detect people
    in a photo is surprisingly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the above, you created a HOG descriptor with the parameters from `cv2.HOGDescriptor_getDefaultPeopleDetector()
    will initialize` an SVM classifier to detect a particular object, which in this
    case is people.
  prefs: []
  type: TYPE_NORMAL
- en: 'You call the descriptor on an image and run the SVM in one pipeline using `hog.detectMultiScale(img)`,
    which returns the **bounding boxes** for each object detected. While the window
    size is fixed, this detection function will resize the image in multiple scales
    to find the best detection result. Even so, the bounding boxes returned are not
    tight. The code above also annotates the people detected by marking the bounding
    box on the image. You may further filter the result using the confidence score
    reported by the detector. Some filtering algorithms, such as non-maximum suppression,
    may be appropriate but are not discussed here. The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/46e81a2db021d8929caebdda3e9b1b25.png)'
  prefs: []
  type: TYPE_IMG
- en: Bounding box as produced by the people detector using HOG in OpenCV
  prefs: []
  type: TYPE_NORMAL
- en: You can see such detectors can find people only if the full body is visible.
    The output has false positives (non-people detected) and false negatives (people
    not detected). Using it to count all people in a crowd scene would be challenging.
    But it is a good start to see how easily you can get something done using OpenCV.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there are not any detectors that come with OpenCV other than
    people. But you can train your own SVM or other models using the HOG as feature
    vectors. Facilitating a machine learning model is the key point of extracting
    feature vectors from an image.
  prefs: []
  type: TYPE_NORMAL
- en: Want to Get Started With Machine Learning with OpenCV?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take my free email crash course now (with sample code).
  prefs: []
  type: TYPE_NORMAL
- en: Click to sign-up and also get a free PDF Ebook version of the course.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section provides more resources on the topic if you are looking to go deeper.
  prefs: []
  type: TYPE_NORMAL
- en: '**Books**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Mastering OpenCV 4 with Python](https://www.amazon.com/Mastering-OpenCV-Python-practical-processing/dp/1789344913),
    2019.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Websites**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenCV, [https://opencv.org/](https://opencv.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'StackOverflow: OpenCV HOG Features Explanation: [https://stackoverflow.com/questions/44972099/opencv-hog-features-explanation](https://stackoverflow.com/questions/44972099/opencv-hog-features-explanation)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, you learned how to use HOG in OpenCV to extract feature vectors
    based on a sliding window. It is an effective approach to finding features that
    can help object detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: How to fetch HOG features from an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the built-in HOG people detector from OpenCV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you have any questions, please leave a comment below.
  prefs: []
  type: TYPE_NORMAL
