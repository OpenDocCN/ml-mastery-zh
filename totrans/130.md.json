["```py\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import StratifiedKFold\n\n# Read data\ndata = pd.read_csv(\"sonar.csv\", header=None)\nX = data.iloc[:, 0:60]\ny = data.iloc[:, 60]\n\n# Label encode the target from string to integer\nencoder = LabelEncoder()\nencoder.fit(y)\ny = encoder.transform(y)\n\n# Convert to 2D PyTorch tensors\nX = torch.tensor(X.values, dtype=torch.float32)\ny = torch.tensor(y, dtype=torch.float32).reshape(-1, 1)\n\n# Define PyTorch model\nclass SonarModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.layer1 = nn.Linear(60, 60)\n        self.act1 = nn.ReLU()\n        self.layer2 = nn.Linear(60, 30)\n        self.act2 = nn.ReLU()\n        self.output = nn.Linear(30, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, x):\n        x = self.act1(self.layer1(x))\n        x = self.act2(self.layer2(x))\n        x = self.sigmoid(self.output(x))\n        return x\n\n# Helper function to train the model and return the validation result\ndef model_train(model, X_train, y_train, X_val, y_val,\n                n_epochs=300, batch_size=16):\n    loss_fn = nn.BCELoss()\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.8)\n    batch_start = torch.arange(0, len(X_train), batch_size)\n\n    model.train()\n    for epoch in range(n_epochs):\n        for start in batch_start:\n            X_batch = X_train[start:start+batch_size]\n            y_batch = y_train[start:start+batch_size]\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n    # evaluate accuracy after training\n    model.eval()\n    y_pred = model(X_val)\n    acc = (y_pred.round() == y_val).float().mean()\n    acc = float(acc)\n    return acc\n\n# run 10-fold cross validation\nkfold = StratifiedKFold(n_splits=10, shuffle=True)\naccuracies = []\nfor train, test in kfold.split(X, y):\n    # create model, train, and get accuracy\n    model = SonarModel()\n    acc = model_train(model, X[train], y[train], X[test], y[test])\n    print(\"Accuracy: %.2f\" % acc)\n    accuracies.append(acc)\n\n# evaluate the model\nmean = np.mean(accuracies)\nstd = np.std(accuracies)\nprint(\"Baseline: %.2f%% (+/- %.2f%%)\" % (mean*100, std*100))\n```", "```py\nAccuracy: 0.81\nAccuracy: 0.81\nAccuracy: 0.76\nAccuracy: 0.86\nAccuracy: 0.81\nAccuracy: 0.90\nAccuracy: 0.86\nAccuracy: 0.95\nAccuracy: 0.65\nAccuracy: 0.80\nBaseline: 82.12% (+/- 7.78%)\n```", "```py\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import StratifiedKFold\n\n# Read data\ndata = pd.read_csv(\"sonar.csv\", header=None)\nX = data.iloc[:, 0:60]\ny = data.iloc[:, 60]\n\n# Label encode the target from string to integer\nencoder = LabelEncoder()\nencoder.fit(y)\ny = encoder.transform(y)\n\n# Convert to 2D PyTorch tensors\nX = torch.tensor(X.values, dtype=torch.float32)\ny = torch.tensor(y, dtype=torch.float32).reshape(-1, 1)\n\n# Define PyTorch model, with dropout at input\nclass SonarModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.dropout = nn.Dropout(0.2)\n        self.layer1 = nn.Linear(60, 60)\n        self.act1 = nn.ReLU()\n        self.layer2 = nn.Linear(60, 30)\n        self.act2 = nn.ReLU()\n        self.output = nn.Linear(30, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, x):\n        x = self.dropout(x)\n        x = self.act1(self.layer1(x))\n        x = self.act2(self.layer2(x))\n        x = self.sigmoid(self.output(x))\n        return x\n\n# Helper function to train the model and return the validation result\ndef model_train(model, X_train, y_train, X_val, y_val,\n                n_epochs=300, batch_size=16):\n    loss_fn = nn.BCELoss()\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.8)\n    batch_start = torch.arange(0, len(X_train), batch_size)\n\n    model.train()\n    for epoch in range(n_epochs):\n        for start in batch_start:\n            X_batch = X_train[start:start+batch_size]\n            y_batch = y_train[start:start+batch_size]\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n    # evaluate accuracy after training\n    model.eval()\n    y_pred = model(X_val)\n    acc = (y_pred.round() == y_val).float().mean()\n    acc = float(acc)\n    return acc\n\n# run 10-fold cross validation\nkfold = StratifiedKFold(n_splits=10, shuffle=True)\naccuracies = []\nfor train, test in kfold.split(X, y):\n    # create model, train, and get accuracy\n    model = SonarModel()\n    acc = model_train(model, X[train], y[train], X[test], y[test])\n    print(\"Accuracy: %.2f\" % acc)\n    accuracies.append(acc)\n\n# evaluate the model\nmean = np.mean(accuracies)\nstd = np.std(accuracies)\nprint(\"Baseline: %.2f%% (+/- %.2f%%)\" % (mean*100, std*100))\n```", "```py\nAccuracy: 0.62\nAccuracy: 0.90\nAccuracy: 0.76\nAccuracy: 0.62\nAccuracy: 0.67\nAccuracy: 0.86\nAccuracy: 0.90\nAccuracy: 0.86\nAccuracy: 0.90\nAccuracy: 0.85\nBaseline: 79.40% (+/- 11.20%)\n```", "```py\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.model_selection import StratifiedKFold\n\n# Read data\ndata = pd.read_csv(\"sonar.csv\", header=None)\nX = data.iloc[:, 0:60]\ny = data.iloc[:, 60]\n\n# Label encode the target from string to integer\nencoder = LabelEncoder()\nencoder.fit(y)\ny = encoder.transform(y)\n\n# Convert to 2D PyTorch tensors\nX = torch.tensor(X.values, dtype=torch.float32)\ny = torch.tensor(y, dtype=torch.float32).reshape(-1, 1)\n\n# Define PyTorch model, with dropout at hidden layers\nclass SonarModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.layer1 = nn.Linear(60, 60)\n        self.act1 = nn.ReLU()\n        self.dropout1 = nn.Dropout(0.2)\n        self.layer2 = nn.Linear(60, 30)\n        self.act2 = nn.ReLU()\n        self.dropout2 = nn.Dropout(0.2)\n        self.output = nn.Linear(30, 1)\n        self.sigmoid = nn.Sigmoid()\n\n    def forward(self, x):\n        x = self.act1(self.layer1(x))\n        x = self.dropout1(x)\n        x = self.act2(self.layer2(x))\n        x = self.dropout2(x)\n        x = self.sigmoid(self.output(x))\n        return x\n\n# Helper function to train the model and return the validation result\ndef model_train(model, X_train, y_train, X_val, y_val,\n                n_epochs=300, batch_size=16):\n    loss_fn = nn.BCELoss()\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.8)\n    batch_start = torch.arange(0, len(X_train), batch_size)\n\n    model.train()\n    for epoch in range(n_epochs):\n        for start in batch_start:\n            X_batch = X_train[start:start+batch_size]\n            y_batch = y_train[start:start+batch_size]\n            y_pred = model(X_batch)\n            loss = loss_fn(y_pred, y_batch)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n    # evaluate accuracy after training\n    model.eval()\n    y_pred = model(X_val)\n    acc = (y_pred.round() == y_val).float().mean()\n    acc = float(acc)\n    return acc\n\n# run 10-fold cross validation\nkfold = StratifiedKFold(n_splits=10, shuffle=True)\naccuracies = []\nfor train, test in kfold.split(X, y):\n    # create model, train, and get accuracy\n    model = SonarModel()\n    acc = model_train(model, X[train], y[train], X[test], y[test])\n    print(\"Accuracy: %.2f\" % acc)\n    accuracies.append(acc)\n\n# evaluate the model\nmean = np.mean(accuracies)\nstd = np.std(accuracies)\nprint(\"Baseline: %.2f%% (+/- %.2f%%)\" % (mean*100, std*100))\n```", "```py\nAccuracy: 0.86\nAccuracy: 1.00\nAccuracy: 0.86\nAccuracy: 0.90\nAccuracy: 0.90\nAccuracy: 0.86\nAccuracy: 0.81\nAccuracy: 0.81\nAccuracy: 0.70\nAccuracy: 0.85\nBaseline: 85.50% (+/- 7.36%)\n```"]