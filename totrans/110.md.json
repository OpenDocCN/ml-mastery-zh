["```py\nimport pandas_datareader as pdr\nimport pandas_datareader.wb\n\ndf = (\n    pdr.wb\n    .download(indicator=\"SP.POP.TOTL\", country=\"all\", start=2000, end=2020)\n    .reset_index()\n    .filter([\"country\", \"SP.POP.TOTL\"])\n    .groupby(\"country\")\n    .mean()\n)\nprint(df)\n```", "```py\n                              SP.POP.TOTL\ncountry                                  \nAfghanistan                  2.976380e+07\nAfrica Eastern and Southern  5.257466e+08\nAfrica Western and Central   3.550782e+08\nAlbania                      2.943192e+06\nAlgeria                      3.658167e+07\n...                                   ...\nWest Bank and Gaza           3.806576e+06\nWorld                        6.930446e+09\nYemen, Rep.                  2.334172e+07\nZambia                       1.393321e+07\nZimbabwe                     1.299188e+07\n```", "```py\nimport pandas_datareader as pdr\nimport pandas_datareader.wb\n\ndf = pdr.wb.download(indicator=\"SP.POP.TOTL\", country=\"all\", start=2000, end=2020)\ndf = df.reset_index()\ndf = df.filter([\"country\", \"SP.POP.TOTL\"])\ngroups = df.groupby(\"country\")\ndf = groups.mean()\n\nprint(df)\n```", "```py\n89.170.74.95 - - [17/May/2015:16:05:27 +0000] \"HEAD /projects/xdotool/ HTTP/1.1\" 200 - \"-\" \"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:24.0) Gecko/20100101 Firefox/24.0\" \n95.82.59.254 - - [19/May/2015:03:05:19 +0000] \"GET /images/jordan-80.png HTTP/1.1\" 200 6146 \"http://www.semicomplete.com/articles/dynamic-dns-with-dhcp/\" \"Mozilla/5.0 (Windows NT 6.1; rv:27.0) Gecko/20100101 Firefox/27.0\"\n155.140.133.248 - - [19/May/2015:06:05:34 +0000] \"GET /images/jordan-80.png HTTP/1.1\" 200 6146 \"http://www.semicomplete.com/blog/geekery/debugging-java-performance.html\" \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0)\"\n68.180.224.225 - - [20/May/2015:20:05:02 +0000] \"GET /blog/tags/documentation HTTP/1.1\" 200 12091 \"-\" \"Mozilla/5.0 (compatible; Yahoo! Slurp; http://help.yahoo.com/help/us/ysearch/slurp)\"\n```", "```py\nimport urllib.request\nimport re\n\n# Read the log file, split into lines\nlogurl = \"https://raw.githubusercontent.com/elastic/examples/master/Common%20Data%20Formats/apache_logs/apache_logs\"\nlogfile = urllib.request.urlopen(logurl).read().decode(\"utf8\")\nlines = logfile.splitlines()\n\n# using regular expression to extract IP address and status code from a line\ndef ip_and_code(logline):\n    m = re.match(r'([\\d\\.]+) .*? \\[.*?\\] \".*?\" (\\d+) ', logline)\n    return (m.group(1), m.group(2))\n\nprint(ip_and_code(lines[0]))\n```", "```py\n...\n\nimport collections\n\ndef is404(pair):\n    return pair[1] == \"404\"\ndef getIP(pair):\n    return pair[0]\ndef count_ip(count_item):\n    ip, count = count_item\n    return (count, ip)\n\n# transform each line into (IP address, status code) pair\nipcodepairs = map(ip_and_code, lines)\n# keep only those with status code 404\npairs404 = filter(is404, ipcodepairs)\n# extract the IP address part from each pair\nip404 = map(getIP, pairs404)\n# count the occurrences, the result is a dictionary of IP addresses map to the count\nipcount = collections.Counter(ip404)\n# convert the (IP address, count) tuple into (count, IP address) order\ncountip = map(count_ip, ipcount.items())\n# find the tuple with the maximum on the count\nprint(max(countip))\n```", "```py\n...\n\nipcodepairs = [ip_and_code(x) for x in lines]\nip404 = [ip for ip,code in ipcodepairs if code==\"404\"]\nipcount = collections.Counter(ip404)\ncountip = [(count,ip) for ip,count in ipcount.items()]\nprint(max(countip))\n```", "```py\nimport urllib.request\nimport re\nimport collections\n\nlogurl = \"https://raw.githubusercontent.com/elastic/examples/master/Common%20Data%20Formats/apache_logs/apache_logs\"\nprint(\n    max(\n        [(count,ip) for ip,count in\n            collections.Counter([\n                ip for ip, code in\n                [ip_and_code(x) for x in\n                     urllib.request.urlopen(logurl)\n                     .read()\n                     .decode(\"utf8\")\n                     .splitlines()\n                ]\n                if code==\"404\"\n            ]).items()\n        ]\n    )\n)\n```", "```py\nimport itertools\nimport operator\n```", "```py\nstart = 0\nstep = 100\nfor i in itertools.count(start, step):\n    print(i)\n    if i>=1000:\n        break\n```", "```py 0\n100\n200\n300\n400\n500\n600\n700\n800\n900\n1000\n```", "```py\ncounter = 0\ncyclic_list = [1, 2, 3, 4, 5]\nfor i in itertools.cycle(cyclic_list):\n    print(i)\n    counter = counter+1\n    if counter>10:\n        break\n```", "```py 1\n2\n3\n4\n5\n1\n2\n3\n4\n5\n1\n```", "```py\nfor i in itertools.repeat(3,5):\n    print(i)\n```", "```py 3\n3\n3\n3\n3\n```", "```py\nx = [1, 2, 3]\ny = ['A', 'B']\nprint(list(itertools.product(x, y)))\n```", "```py [(1, 'A'), (1, 'B'), (2, 'A'), (2, 'B'), \n (3, 'A'), (3, 'B')]\n```", "```py\nx = [1, 2, 3]\nprint(list(itertools.permutations(x)))\n```", "```py [(1, 2, 3), (1, 3, 2), (2, 1, 3), \n (2, 3, 1), (3, 1, 2), (3, 2, 1)]\n```", "```py\ny = ['A', 'B', 'C', 'D']\nprint(list(itertools.combinations(y, 3)))\n```", "```py [('A', 'B', 'C'), ('A', 'B', 'D'), \n ('A', 'C', 'D'), ('B', 'C', 'D')]\n```", "```py\nz = ['A', 'B', 'C']\nprint(list(itertools.combinations_with_replacement(z, 2)))\n```", "```py [('A', 'A'), ('A', 'B'), ('A', 'C'), \n ('B', 'B'), ('B', 'C'), ('C', 'C')]\n```", "```py\n# Custom operator\ndef my_operator(a, b):\n    return a+b if a>5 else a-b\n\nx = [2, 3, 4, -6]\nmul_result = itertools.accumulate(x, operator.mul)\nprint(\"After mul operator\", list(mul_result))\npow_result = itertools.accumulate(x, operator.pow)\nprint(\"After pow operator\", list(pow_result))\nmy_operator_result = itertools.accumulate(x, my_operator)\nprint(\"After customized my_operator\", list(my_operator_result))\n```", "```py\nAfter mul operator [2, 6, 24, -144]\nAfter pow operator [2, 8, 4096, 2.117582368135751e-22]\nAfter customized my_operator [2, -1, -5, 1]\n```", "```py\npair_list = [(1, 2), (4, 0.5), (5, 7), (100, 10)]\n\nstarmap_add_result = itertools.starmap(operator.add, pair_list)\nprint(\"Starmap add result: \", list(starmap_add_result))\n\nx1 = [2, 3, 4, -6]\nx2 = [4, 3, 2, 1] \n\nstarmap_mul_result = itertools.starmap(operator.mul, zip(x1, x2))\nprint(\"Starmap mul result: \", list(starmap_mul_result))\n```", "```py\nStarmap add result:  [3, 4.5, 12, 110]\nStarmap mul result:  [8, 9, 8, -6]\n```", "```py\nmy_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_result = itertools.filterfalse(lambda x: x%2, my_list)\nsmall_terms = itertools.filterfalse(lambda x: x>=5, my_list)                               \nprint('Even result:', list(even_result))\nprint('Less than 5:', list(small_terms))\n```", "```py\nEven result: [2, 4, 6, 8, 10]\nLess than 5: [1, 2, 3, 4]\n```", "```py\nimport functools\n@functools.lru_cache\ndef fib(n):\n    global count\n    count = count + 1\n    return fib(n-2) + fib(n-1) if n>1 else 1\n\ndef fib_slow(n):\n    global slow_count\n    slow_count = slow_count + 1\n    return fib_slow(n-2) + fib_slow(n-1) if n>1 else 1\n\ncount = 0\nslow_count = 0\nfib(30)\nfib_slow(30)\n\nprint('With lru_cache total function evaluations: ', count)\nprint('Without lru_cache total function evaluations: ', slow_count)\n```", "```py\nWith lru_cache total function evaluations:  31\nWithout lru_cache total function evaluations:  2692537\n```", "```py\n# Evaluates ((1+2)+3)+4\nlist_sum = functools.reduce(operator.add, [1, 2, 3, 4])\nprint(list_sum)\n\n# Evaluates (2^3)^4\nlist_pow = functools.reduce(operator.pow, [2, 3, 4])\nprint(list_pow)\n```", "```py\n10\n4096\n```", "```py\nimport functools\n\ndef addcount(counter, element):\n    if element not in counter:\n        counter[element] = 1\n    else:\n        counter[element] += 1\n    return counter\n\nitems = [\"a\", \"b\", \"a\", \"c\", \"d\", \"c\", \"b\", \"a\"]\n\ncounts = functools.reduce(addcount, items, {})\nprint(counts)\n```", "```py\n{'a': 3, 'b': 2, 'c': 2, 'd': 1}\n```", "```py\nimport numpy\n\npower_2 = functools.partial(np.power, 2)\nprint('2^4 =', power_2(4))\nprint('2^6 =', power_2(6))\n```", "```py\n2^4 = 16\n2^6 = 64\n```", "```py\n# All numbers from 1 to 20\ninput_list = list(range(20))\n# Use map to see which numbers are divisible by 3\nbool_list = map(lambda x: 1 if x%3==0 else 0, input_list)\n# Convert map object to list\nbool_list = list(bool_list)\nprint('bool_list =', bool_list)\n\ntotal_divisible_3 = functools.reduce(operator.add, bool_list)\nprint('Total items divisible by 3 = ', total_divisible_3)\n```", "```py\nbool_list = [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]\nTotal items divisible by 3 =  7\n```"]