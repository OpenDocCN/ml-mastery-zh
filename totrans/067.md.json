["```py\nfrom cv2 import imread, IMREAD_GRAYSCALE\nfrom numpy import hsplit, vsplit, array\n\ndef split_images(img_name, img_size):\n\n    # Load the full image from the specified file\n    img = imread(img_name, IMREAD_GRAYSCALE)\n\n    # Find the number of sub-images on each row and column according to their size\n    num_rows = img.shape[0] / img_size\n    num_cols = img.shape[1] / img_size\n\n    # Split the full image horizontally and vertically into sub-images\n    sub_imgs = [hsplit(row, num_cols) for row in vsplit(img, num_rows)]\n\n    return img, array(sub_imgs)\n```", "```py\nfrom numpy import float32, arange, repeat, newaxis\n\ndef split_data(img_size, sub_imgs, ratio):\n\n    # Compute the partition between the training and testing data\n    partition = int(sub_imgs.shape[1] * ratio)\n\n    # Split dataset into training and testing sets\n    train = sub_imgs[:, :partition, :, :]\n    test = sub_imgs[:, partition:sub_imgs.shape[1], :, :]\n\n    # Flatten each image into a one-dimensional vector\n    train_imgs = train.reshape(-1, img_size ** 2)\n    test_imgs = test.reshape(-1, img_size ** 2)\n\n    # Create the ground truth labels\n    labels = arange(10)\n    train_labels = repeat(labels, train_imgs.shape[0] / labels.shape[0])[:, newaxis]\n    test_labels = repeat(labels, test_imgs.shape[0] / labels.shape[0])[:, newaxis]\n\n    return train_imgs, train_labels, test_imgs, test_labels\n```", "```py\nfrom pickle import load\nfrom numpy import array, newaxis\n\ndef load_images(path):\n\n    # Create empty lists to store the images and labels\n    imgs = []\n    labels = []\n\n    # Iterate over the dataset's files\n    for batch in range(5):\n\n        # Specify the path to the training data\n        train_path_batch = path + 'data_batch_' + str(batch + 1)\n\n        # Extract the training images and labels from the dataset files\n        train_imgs_batch, train_labels_batch = extract_data(train_path_batch)\n\n        # Store the training images\n        imgs.append(train_imgs_batch)\n        train_imgs = array(imgs).reshape(-1, 3072)\n\n        # Store the training labels\n        labels.append(train_labels_batch)\n        train_labels = array(labels).reshape(-1, 1)\n\n    # Specify the path to the testing data\n    test_path_batch = path + 'test_batch'\n\n    # Extract the testing images and labels from the dataset files\n    test_imgs, test_labels = extract_data(test_path_batch)\n    test_labels = array(test_labels)[:, newaxis]\n\n    return train_imgs, train_labels, test_imgs, test_labels\n\ndef extract_data(path):\n\n    # Open pickle file and return a dictionary\n    with open(path, 'rb') as fo:\n        dict = load(fo, encoding='bytes')\n\n    # Extract the dictionary values\n    dict_values = list(dict.values())\n\n    # Extract the images and labels\n    imgs = dict_values[2]\n    labels = dict_values[1]\n\n    return imgs, labels\n```", "```py\nfrom digits_dataset import split_images, split_data\nfrom cifar_dataset import load_images\n\n# Load the digits image\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Obtain training and testing datasets from the digits image\ndigits_train_imgs, digits_train_labels, digits_test_imgs, digits_test_labels = split_data(20, sub_imgs, 0.8)\n\n# Obtain training and testing datasets from the CIFAR-10 dataset\ncifar_train_imgs, cifar_train_labels, cifar_test_imgs, cifar_test_labels = load_images('Images/cifar-10-batches-py/')\n```"]