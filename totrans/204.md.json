["```py\nfrom pandas import read_csv\nimport numpy as np\nfrom keras.models import Sequential\nfrom keras.layers import Dense, SimpleRNN\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.metrics import mean_squared_error\nimport math\nimport matplotlib.pyplot as plt\n```", "```py\ndef create_RNN(hidden_units, dense_units, input_shape, activation):\n    model = Sequential()\n    model.add(SimpleRNN(hidden_units, input_shape=input_shape, \n                        activation=activation[0]))\n    model.add(Dense(units=dense_units, activation=activation[1]))\n    model.compile(loss='mean_squared_error', optimizer='adam')\n    return model\n\ndemo_model = create_RNN(2, 1, (3,1), activation=['linear', 'linear'])\n```", "```py\nwx = demo_model.get_weights()[0]\nwh = demo_model.get_weights()[1]\nbh = demo_model.get_weights()[2]\nwy = demo_model.get_weights()[3]\nby = demo_model.get_weights()[4]\n\nprint('wx = ', wx, ' wh = ', wh, ' bh = ', bh, ' wy =', wy, 'by = ', by)\n```", "```py\nwx =  [[ 0.18662322 -1.2369459 ]]  wh =  [[ 0.86981213 -0.49338293]\n [ 0.49338293  0.8698122 ]]  bh =  [0\\. 0.]  wy = [[-0.4635998]\n [ 0.6538409]] by =  [0.]\n```", "```py\nx = np.array([1, 2, 3])\n# Reshape the input to the required sample_size x time_steps x features \nx_input = np.reshape(x,(1, 3, 1))\ny_pred_model = demo_model.predict(x_input)\n\nm = 2\nh0 = np.zeros(m)\nh1 = np.dot(x[0], wx) + h0 + bh\nh2 = np.dot(x[1], wx) + np.dot(h1,wh) + bh\nh3 = np.dot(x[2], wx) + np.dot(h2,wh) + bh\no3 = np.dot(h3, wy) + by\n\nprint('h1 = ', h1,'h2 = ', h2,'h3 = ', h3)\n\nprint(\"Prediction from network \", y_pred_model)\nprint(\"Prediction from our computation \", o3)\n```", "```py\nh1 =  [[ 0.18662322 -1.23694587]] h2 =  [[-0.07471441 -3.64187904]] h3 =  [[-1.30195881 -6.84172557]]\nPrediction from network  [[-3.8698118]]\nPrediction from our computation  [[-3.86981216]]\n```", "```py\n# Parameter split_percent defines the ratio of training examples\ndef get_train_test(url, split_percent=0.8):\n    df = read_csv(url, usecols=[1], engine='python')\n    data = np.array(df.values.astype('float32'))\n    scaler = MinMaxScaler(feature_range=(0, 1))\n    data = scaler.fit_transform(data).flatten()\n    n = len(data)\n    # Point for splitting data into train and test\n    split = int(n*split_percent)\n    train_data = data[range(split)]\n    test_data = data[split:]\n    return train_data, test_data, data\n\nsunspots_url = 'https://raw.githubusercontent.com/jbrownlee/Datasets/master/monthly-sunspots.csv'\ntrain_data, test_data, data = get_train_test(sunspots_url)\n```", "```py\n# Prepare the input X and target Y\ndef get_XY(dat, time_steps):\n    # Indices of target array\n    Y_ind = np.arange(time_steps, len(dat), time_steps)\n    Y = dat[Y_ind]\n    # Prepare X\n    rows_x = len(Y)\n    X = dat[range(time_steps*rows_x)]\n    X = np.reshape(X, (rows_x, time_steps, 1))    \n    return X, Y\n\ntime_steps = 12\ntrainX, trainY = get_XY(train_data, time_steps)\ntestX, testY = get_XY(test_data, time_steps)\n```", "```py\nmodel = create_RNN(hidden_units=3, dense_units=1, input_shape=(time_steps,1), \n                   activation=['tanh', 'tanh'])\nmodel.fit(trainX, trainY, epochs=20, batch_size=1, verbose=2)\n```", "```py\ndef print_error(trainY, testY, train_predict, test_predict):    \n    # Error of predictions\n    train_rmse = math.sqrt(mean_squared_error(trainY, train_predict))\n    test_rmse = math.sqrt(mean_squared_error(testY, test_predict))\n    # Print RMSE\n    print('Train RMSE: %.3f RMSE' % (train_rmse))\n    print('Test RMSE: %.3f RMSE' % (test_rmse))    \n\n# make predictions\ntrain_predict = model.predict(trainX)\ntest_predict = model.predict(testX)\n# Mean square error\nprint_error(trainY, testY, train_predict, test_predict)\n```", "```py\nTrain RMSE: 0.058 RMSE\nTest RMSE: 0.077 RMSE\n```", "```py\n# Plot the result\ndef plot_result(trainY, testY, train_predict, test_predict):\n    actual = np.append(trainY, testY)\n    predictions = np.append(train_predict, test_predict)\n    rows = len(actual)\n    plt.figure(figsize=(15, 6), dpi=80)\n    plt.plot(range(rows), actual)\n    plt.plot(range(rows), predictions)\n    plt.axvline(x=len(trainY), color='r')\n    plt.legend(['Actual', 'Predictions'])\n    plt.xlabel('Observation number after given time steps')\n    plt.ylabel('Sunspots scaled')\n    plt.title('Actual and Predicted Values. The Red Line Separates The Training And Test Examples')\nplot_result(trainY, testY, train_predict, test_predict)\n```", "```py\n# Parameter split_percent defines the ratio of training examples\ndef get_train_test(url, split_percent=0.8):\n    df = read_csv(url, usecols=[1], engine='python')\n    data = np.array(df.values.astype('float32'))\n    scaler = MinMaxScaler(feature_range=(0, 1))\n    data = scaler.fit_transform(data).flatten()\n    n = len(data)\n    # Point for splitting data into train and test\n    split = int(n*split_percent)\n    train_data = data[range(split)]\n    test_data = data[split:]\n    return train_data, test_data, data\n\n# Prepare the input X and target Y\ndef get_XY(dat, time_steps):\n    Y_ind = np.arange(time_steps, len(dat), time_steps)\n    Y = dat[Y_ind]\n    rows_x = len(Y)\n    X = dat[range(time_steps*rows_x)]\n    X = np.reshape(X, (rows_x, time_steps, 1))    \n    return X, Y\n\ndef create_RNN(hidden_units, dense_units, input_shape, activation):\n    model = Sequential()\n    model.add(SimpleRNN(hidden_units, input_shape=input_shape, activation=activation[0]))\n    model.add(Dense(units=dense_units, activation=activation[1]))\n    model.compile(loss='mean_squared_error', optimizer='adam')\n    return model\n\ndef print_error(trainY, testY, train_predict, test_predict):    \n    # Error of predictions\n    train_rmse = math.sqrt(mean_squared_error(trainY, train_predict))\n    test_rmse = math.sqrt(mean_squared_error(testY, test_predict))\n    # Print RMSE\n    print('Train RMSE: %.3f RMSE' % (train_rmse))\n    print('Test RMSE: %.3f RMSE' % (test_rmse))    \n\n# Plot the result\ndef plot_result(trainY, testY, train_predict, test_predict):\n    actual = np.append(trainY, testY)\n    predictions = np.append(train_predict, test_predict)\n    rows = len(actual)\n    plt.figure(figsize=(15, 6), dpi=80)\n    plt.plot(range(rows), actual)\n    plt.plot(range(rows), predictions)\n    plt.axvline(x=len(trainY), color='r')\n    plt.legend(['Actual', 'Predictions'])\n    plt.xlabel('Observation number after given time steps')\n    plt.ylabel('Sunspots scaled')\n    plt.title('Actual and Predicted Values. The Red Line Separates The Training And Test Examples')\n\nsunspots_url = 'https://raw.githubusercontent.com/jbrownlee/Datasets/master/monthly-sunspots.csv'\ntime_steps = 12\ntrain_data, test_data, data = get_train_test(sunspots_url)\ntrainX, trainY = get_XY(train_data, time_steps)\ntestX, testY = get_XY(test_data, time_steps)\n\n# Create model and train\nmodel = create_RNN(hidden_units=3, dense_units=1, input_shape=(time_steps,1), \n                   activation=['tanh', 'tanh'])\nmodel.fit(trainX, trainY, epochs=20, batch_size=1, verbose=2)\n\n# make predictions\ntrain_predict = model.predict(trainX)\ntest_predict = model.predict(testX)\n\n# Print error\nprint_error(trainY, testY, train_predict, test_predict)\n\n#Plot result\nplot_result(trainY, testY, train_predict, test_predict)\n```"]