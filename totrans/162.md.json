["```py\nimport torch\nfrom torch.utils.data import Dataset\ntorch.manual_seed(42)\n```", "```py\nclass SimpleDataset(Dataset):\n    # defining values in the constructor\n    def __init__(self, data_length = 20, transform = None):\n        self.x = 3 * torch.eye(data_length, 2)\n        self.y = torch.eye(data_length, 4)\n        self.transform = transform\n        self.len = data_length\n\n    # Getting the data samples\n    def __getitem__(self, idx):\n        sample = self.x[idx], self.y[idx]\n        if self.transform:\n            sample = self.transform(sample)     \n        return sample\n\n    # Getting data size/length\n    def __len__(self):\n        return self.len\n```", "```py\ndataset = SimpleDataset()\nprint(\"length of the SimpleDataset object: \", len(dataset))\nprint(\"accessing value at index 1 of the simple_dataset object: \", dataset[1])\n```", "```py\nlength of the SimpleDataset object:  20\naccessing value at index 1 of the simple_dataset object:  (tensor([0., 3.]), tensor([0., 1., 0., 0.]))\n```", "```py\nfor i in range(4):\n    x, y = dataset[i]\n    print(x, y)\n```", "```py\ntensor([3., 0.]) tensor([1., 0., 0., 0.])\ntensor([0., 3.]) tensor([0., 1., 0., 0.])\ntensor([0., 0.]) tensor([0., 0., 1., 0.])\ntensor([0., 0.]) tensor([0., 0., 0., 1.])\n```", "```py\n# Creating a callable tranform class mult_divide\nclass MultDivide:\n    # Constructor\n    def __init__(self, mult_x = 2, divide_y = 3):\n        self.mult_x = mult_x\n        self.divide_y = divide_y\n\n    # caller\n    def __call__(self, sample):\n        x = sample[0]\n        y = sample[1]\n        x = x * self.mult_x\n        y = y / self.divide_y\n        sample = x, y\n        return sample\n```", "```py\n# calling the transform object\nmul_div = MultDivide()\ncustom_dataset = SimpleDataset(transform = mul_div)\n\nfor i in range(4):\n    x, y = dataset[i]\n    print('Idx: ', i, 'Original_x: ', x, 'Original_y: ', y)\n    x_, y_ = custom_dataset[i]\n    print('Idx: ', i, 'Transformed_x:', x_, 'Transformed_y:', y_)\n```", "```py\nIdx:  0 Original_x:  tensor([3., 0.]) Original_y:  tensor([1., 0., 0., 0.])\nIdx:  0 Transformed_x: tensor([6., 0.]) Transformed_y: tensor([0.3333, 0.0000, 0.0000, 0.0000])\nIdx:  1 Original_x:  tensor([0., 3.]) Original_y:  tensor([0., 1., 0., 0.])\nIdx:  1 Transformed_x: tensor([0., 6.]) Transformed_y: tensor([0.0000, 0.3333, 0.0000, 0.0000])\nIdx:  2 Original_x:  tensor([0., 0.]) Original_y:  tensor([0., 0., 1., 0.])\nIdx:  2 Transformed_x: tensor([0., 0.]) Transformed_y: tensor([0.0000, 0.0000, 0.3333, 0.0000])\nIdx:  3 Original_x:  tensor([0., 0.]) Original_y:  tensor([0., 0., 0., 1.])\nIdx:  3 Transformed_x: tensor([0., 0.]) Transformed_y: tensor([0.0000, 0.0000, 0.0000, 0.3333])\n```", "```py\nfrom torchvision import transforms\n\n# Creating subtract_one tranform\nclass SubtractOne:\n    # Constructor\n    def __init__(self, number = 1):\n        self.number = number\n\n    # caller\n    def __call__(self, sample):\n        x = sample[0]\n        y = sample[1]\n        x = x - self.number\n        y = y - self.number\n        sample = x, y\n        return sample\n```", "```py\n# Composing multiple transforms\nmult_transforms = transforms.Compose([MultDivide(), SubtractOne()])\n```", "```py\n# Creating a new simple_dataset object with multiple transforms\nnew_dataset = SimpleDataset(transform = mult_transforms)\n```", "```py\nfor i in range(4):\n    x, y = dataset[i]\n    print('Idx: ', i, 'Original_x: ', x, 'Original_y: ', y)\n    x_, y_ = new_dataset[i]\n    print('Idx: ', i, 'Transformed x_:', x_, 'Transformed y_:', y_)\n```", "```py\nimport torch\nfrom torch.utils.data import Dataset\nfrom torchvision import transforms\n\ntorch.manual_seed(2)\n\nclass SimpleDataset(Dataset):\n    # defining values in the constructor\n    def __init__(self, data_length = 20, transform = None):\n        self.x = 3 * torch.eye(data_length, 2)\n        self.y = torch.eye(data_length, 4)\n        self.transform = transform\n        self.len = data_length\n\n    # Getting the data samples\n    def __getitem__(self, idx):\n        sample = self.x[idx], self.y[idx]\n        if self.transform:\n            sample = self.transform(sample)     \n        return sample\n\n    # Getting data size/length\n    def __len__(self):\n        return self.len\n\n# Creating a callable tranform class mult_divide\nclass MultDivide:\n    # Constructor\n    def __init__(self, mult_x = 2, divide_y = 3):\n        self.mult_x = mult_x\n        self.divide_y = divide_y\n\n    # caller\n    def __call__(self, sample):\n        x = sample[0]\n        y = sample[1]\n        x = x * self.mult_x\n        y = y / self.divide_y\n        sample = x, y\n        return sample\n\n# Creating subtract_one tranform\nclass SubtractOne:\n    # Constructor\n    def __init__(self, number = 1):\n        self.number = number\n\n    # caller\n    def __call__(self, sample):\n        x = sample[0]\n        y = sample[1]\n        x = x - self.number\n        y = y - self.number\n        sample = x, y\n        return sample\n\n# Composing multiple transforms\nmult_transforms = transforms.Compose([MultDivide(), SubtractOne()])\n\n# Creating a new simple_dataset object with multiple transforms\ndataset = SimpleDataset()\nnew_dataset = SimpleDataset(transform = mult_transforms)\n\nprint(\"length of the simple_dataset object: \", len(dataset))\nprint(\"accessing value at index 1 of the simple_dataset object: \", dataset[1])\n\nfor i in range(4):\n    x, y = dataset[i]\n    print('Idx: ', i, 'Original_x: ', x, 'Original_y: ', y)\n    x_, y_ = new_dataset[i]\n    print('Idx: ', i, 'Transformed x_:', x_, 'Transformed y_:', y_)\n```"]