["```py\nimport cv2\n\nimgfile = \"Hooded_mountain_tanager_(Buthraupis_montana_cucullata)_Caldas.jpg\"\n\nimg = cv2.imread(imgfile, cv2.IMREAD_COLOR)\ncv2.imshow(\"bird\", img)\ncv2.waitKey(0)\n```", "```py\ncropped = img[y0:y1, x0:x1]\n```", "```py\nresized = cv2.resize(cropped, dsize=target_dim, interpolation=cv2.INTER_LINEAR)\n```", "```py\nimgfile = \"Hooded_mountain_tanager_(Buthraupis_montana_cucullata)_Caldas.jpg\"\nvideo_dim = (1280, 720)\nfps = 25\nduration = 2.0\nstart_center = (0.4, 0.6)\nend_center = (0.5, 0.5)\nstart_scale = 0.7\nend_scale = 1.0\n```", "```py\ndef crop(img, x, y, w, h):\n    x0, y0 = max(0, x-w//2), max(0, y-h//2)\n    x1, y1 = x0+w, y0+h\n    return img[y0:y1, x0:x1]\n```", "```py\nrx = end_center[0]*alpha + start_center[0]*(1-alpha)\nry = end_center[1]*alpha + start_center[1]*(1-alpha)\n```", "```py\nscale = end_scale*alpha + start_scale*(1-alpha)\n```", "```py\norig_shape = img.shape[:2]\n\nif orig_shape[1]/orig_shape[0] > video_dim[0]/video_dim[1]:\n    h = int(orig_shape[0]*scale)\n    w = int(h * video_dim[0] / video_dim[1])\nelse:\n    w = int(orig_shape[1]*scale)\n    h = int(w * video_dim[1] / video_dim[0])\n```", "```py\nimport cv2\nimport numpy as np\n\nimgfile = \"Hooded_mountain_tanager_(Buthraupis_montana_cucullata)_Caldas.jpg\"\nvideo_dim = (1280, 720)\nfps = 25\nduration = 2.0\nstart_center = (0.4, 0.6)\nend_center = (0.5, 0.5)\nstart_scale = 0.7\nend_scale = 1.0\n\nimg = cv2.imread(imgfile, cv2.IMREAD_COLOR)\norig_shape = img.shape[:2]\n\ndef crop(img, x, y, w, h):\n    x0, y0 = max(0, x-w//2), max(0, y-h//2)\n    x1, y1 = x0+w, y0+h\n    return img[y0:y1, x0:x1]\n\nnum_frames = int(fps * duration)\nframes = []\nfor alpha in np.linspace(0, 1, num_frames):\n    rx = end_center[0]*alpha + start_center[0]*(1-alpha)\n    ry = end_center[1]*alpha + start_center[1]*(1-alpha)\n    x = int(orig_shape[1]*rx)\n    y = int(orig_shape[0]*ry)\n    scale = end_scale*alpha + start_scale*(1-alpha)\n    # determined how to crop based on the aspect ratio of width/height\n    if orig_shape[1]/orig_shape[0] > video_dim[0]/video_dim[1]:\n        h = int(orig_shape[0]*scale)\n        w = int(h * video_dim[0] / video_dim[1])\n    else:\n        w = int(orig_shape[1]*scale)\n        h = int(w * video_dim[1] / video_dim[0])\n    # crop, scale to video size, and save the frame\n    cropped = crop(img, x, y, w, h)\n    scaled = cv2.resize(cropped, dsize=video_dim, interpolation=cv2.INTER_LINEAR)\n    frames.append(scaled)\n\n# write to MP4 file\nvidwriter = cv2.VideoWriter(\"output.mp4\", cv2.VideoWriter_fourcc(*\"mp4v\"), fps, video_dim)\nfor frame in frames:\n    vidwriter.write(frame)\nvidwriter.release()\n```", "```py\nvidwriter = cv2.VideoWriter(\"output.mp4\", cv2.VideoWriter_fourcc(*\"mp4v\"), fps, video_dim)\n```", "```py\nffmpeg -codecs\n```", "```py\ntry:\n    fourcc = cv2.VideoWriter_fourcc(*\"mp4v\")\n    writer = cv2.VideoWriter('temp.mkv', fourcc, 30, (640, 480))\n    assert writer.isOpened()\n    print(\"Supported\")\nexcept:\n    print(\"Not supported\")\n```"]