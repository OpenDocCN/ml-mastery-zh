["```py\n\"Month\",\"Passengers\"\n\"1949-01\",112\n\"1949-02\",118\n\"1949-03\",132\n\"1949-04\",129\n```", "```py\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndf = pd.read_csv('airline-passengers.csv')\ntimeseries = df[[\"Passengers\"]].values.astype('float32')\n\nplt.plot(timeseries)\nplt.show()\n```", "```py\n# train-test split for time series\ntrain_size = int(len(timeseries) * 0.67)\ntest_size = len(timeseries) - train_size\ntrain, test = timeseries[:train_size], timeseries[train_size:]\n```", "```py\nimport torch\n\ndef create_dataset(dataset, lookback):\n    \"\"\"Transform a time series into a prediction dataset\n\n    Args:\n        dataset: A numpy array of time series, first dimension is the time steps\n        lookback: Size of window for prediction\n    \"\"\"\n    X, y = [], []\n    for i in range(len(dataset)-lookback):\n        feature = dataset[i:i+lookback]\n        target = dataset[i+1:i+lookback+1]\n        X.append(feature)\n        y.append(target)\n    return torch.tensor(X), torch.tensor(y)\n```", "```py\nlookback = 1\nX_train, y_train = create_dataset(train, lookback=lookback)\nX_test, y_test = create_dataset(test, lookback=lookback)\nprint(X_train.shape, y_train.shape)\nprint(X_test.shape, y_test.shape)\n```", "```py\ntorch.Size([95, 1, 1]) torch.Size([95, 1, 1])\ntorch.Size([47, 1, 1]) torch.Size([47, 1, 1])\n```", "```py\n...\nimport torch.nn as nn\n\nclass AirModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.lstm = nn.LSTM(input_size=1, hidden_size=50, num_layers=1, batch_first=True)\n        self.linear = nn.Linear(50, 1)\n    def forward(self, x):\n        x, _ = self.lstm(x)\n        x = self.linear(x)\n        return x\n```", "```py\nx, _ = self.lstm(x)\n# extract only the last time step\nx = x[:, -1, :]\nx = self.linear(x)\n```", "```py\nimport numpy as np\nimport torch.optim as optim\nimport torch.utils.data as data\n\nmodel = AirModel()\noptimizer = optim.Adam(model.parameters())\nloss_fn = nn.MSELoss()\nloader = data.DataLoader(data.TensorDataset(X_train, y_train), shuffle=True, batch_size=8)\n\nn_epochs = 2000\nfor epoch in range(n_epochs):\n    model.train()\n    for X_batch, y_batch in loader:\n        y_pred = model(X_batch)\n        loss = loss_fn(y_pred, y_batch)\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    # Validation\n    if epoch % 100 != 0:\n        continue\n    model.eval()\n    with torch.no_grad():\n        y_pred = model(X_train)\n        train_rmse = np.sqrt(loss_fn(y_pred, y_train))\n        y_pred = model(X_test)\n        test_rmse = np.sqrt(loss_fn(y_pred, y_test))\n    print(\"Epoch %d: train RMSE %.4f, test RMSE %.4f\" % (epoch, train_rmse, test_rmse))\n```", "```py\nEpoch 0: train RMSE 225.7571, test RMSE 422.1521\nEpoch 100: train RMSE 186.7353, test RMSE 381.3285\nEpoch 200: train RMSE 153.3157, test RMSE 345.3290\nEpoch 300: train RMSE 124.7137, test RMSE 312.8820\nEpoch 400: train RMSE 101.3789, test RMSE 283.7040\nEpoch 500: train RMSE 83.0900, test RMSE 257.5325\nEpoch 600: train RMSE 66.6143, test RMSE 232.3288\nEpoch 700: train RMSE 53.8428, test RMSE 209.1579\nEpoch 800: train RMSE 44.4156, test RMSE 188.3802\nEpoch 900: train RMSE 37.1839, test RMSE 170.3186\nEpoch 1000: train RMSE 32.0921, test RMSE 154.4092\nEpoch 1100: train RMSE 29.0402, test RMSE 141.6920\nEpoch 1200: train RMSE 26.9721, test RMSE 131.0108\nEpoch 1300: train RMSE 25.7398, test RMSE 123.2518\nEpoch 1400: train RMSE 24.8011, test RMSE 116.7029\nEpoch 1500: train RMSE 24.7705, test RMSE 112.1551\nEpoch 1600: train RMSE 24.4654, test RMSE 108.1879\nEpoch 1700: train RMSE 25.1378, test RMSE 105.8224\nEpoch 1800: train RMSE 24.1940, test RMSE 101.4219\nEpoch 1900: train RMSE 23.4605, test RMSE 100.1780\n```", "```py\nwith torch.no_grad():\n    # shift train predictions for plotting\n    train_plot = np.ones_like(timeseries) * np.nan\n    y_pred = model(X_train)\n    y_pred = y_pred[:, -1, :]\n    train_plot[lookback:train_size] = model(X_train)[:, -1, :]\n    # shift test predictions for plotting\n    test_plot = np.ones_like(timeseries) * np.nan\n    test_plot[train_size+lookback:len(timeseries)] = model(X_test)[:, -1, :]\n# plot\nplt.plot(timeseries, c='b')\nplt.plot(train_plot, c='r')\nplt.plot(test_plot, c='g')\nplt.show()\n```", "```py\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport torch.utils.data as data\n\ndf = pd.read_csv('airline-passengers.csv')\ntimeseries = df[[\"Passengers\"]].values.astype('float32')\n\n# train-test split for time series\ntrain_size = int(len(timeseries) * 0.67)\ntest_size = len(timeseries) - train_size\ntrain, test = timeseries[:train_size], timeseries[train_size:]\n\ndef create_dataset(dataset, lookback):\n    \"\"\"Transform a time series into a prediction dataset\n\n    Args:\n        dataset: A numpy array of time series, first dimension is the time steps\n        lookback: Size of window for prediction\n    \"\"\"\n    X, y = [], []\n    for i in range(len(dataset)-lookback):\n        feature = dataset[i:i+lookback]\n        target = dataset[i+1:i+lookback+1]\n        X.append(feature)\n        y.append(target)\n    return torch.tensor(X), torch.tensor(y)\n\nlookback = 4\nX_train, y_train = create_dataset(train, lookback=lookback)\nX_test, y_test = create_dataset(test, lookback=lookback)\n\nclass AirModel(nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.lstm = nn.LSTM(input_size=1, hidden_size=50, num_layers=1, batch_first=True)\n        self.linear = nn.Linear(50, 1)\n    def forward(self, x):\n        x, _ = self.lstm(x)\n        x = self.linear(x)\n        return x\n\nmodel = AirModel()\noptimizer = optim.Adam(model.parameters())\nloss_fn = nn.MSELoss()\nloader = data.DataLoader(data.TensorDataset(X_train, y_train), shuffle=True, batch_size=8)\n\nn_epochs = 2000\nfor epoch in range(n_epochs):\n    model.train()\n    for X_batch, y_batch in loader:\n        y_pred = model(X_batch)\n        loss = loss_fn(y_pred, y_batch)\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n    # Validation\n    if epoch % 100 != 0:\n        continue\n    model.eval()\n    with torch.no_grad():\n        y_pred = model(X_train)\n        train_rmse = np.sqrt(loss_fn(y_pred, y_train))\n        y_pred = model(X_test)\n        test_rmse = np.sqrt(loss_fn(y_pred, y_test))\n    print(\"Epoch %d: train RMSE %.4f, test RMSE %.4f\" % (epoch, train_rmse, test_rmse))\n\nwith torch.no_grad():\n    # shift train predictions for plotting\n    train_plot = np.ones_like(timeseries) * np.nan\n    y_pred = model(X_train)\n    y_pred = y_pred[:, -1, :]\n    train_plot[lookback:train_size] = model(X_train)[:, -1, :]\n    # shift test predictions for plotting\n    test_plot = np.ones_like(timeseries) * np.nan\n    test_plot[train_size+lookback:len(timeseries)] = model(X_test)[:, -1, :]\n# plot\nplt.plot(timeseries)\nplt.plot(train_plot, c='r')\nplt.plot(test_plot, c='g')\nplt.show()\n```"]