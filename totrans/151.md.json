["```py\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\ntorch.manual_seed(42)\n\n# Creating the dataset class\nclass Data(Dataset):\n    # Constructor\n    def __init__(self):\n        self.x = torch.zeros(40, 2)\n        self.x[:, 0] = torch.arange(-2, 2, 0.1)\n        self.x[:, 1] = torch.arange(-2, 2, 0.1)\n        w = torch.tensor([[1.0, 2.0], [2.0, 4.0]])\n        b = 1\n        func = torch.mm(self.x, w) + b    \n        self.y = func + 0.2 * torch.randn((self.x.shape[0],1))\n        self.len = self.x.shape[0]\n    # Getter\n    def __getitem__(self, idx):          \n        return self.x[idx], self.y[idx] \n    # getting data length\n    def __len__(self):\n        return self.len\n```", "```py\n# Creating dataset object\ndata_set = Data()\n```", "```py\n...\n# Creating a custom Multiple Linear Regression Model\nclass MultipleLinearRegression(torch.nn.Module):\n    # Constructor\n    def __init__(self, input_dim, output_dim):\n        super(MultipleLinearRegression, self).__init__()\n        self.linear = torch.nn.Linear(input_dim, output_dim)\n    # Prediction\n    def forward(self, x):\n        y_pred = self.linear(x)\n        return y_pred\n```", "```py\n...\n# Creating the model object\nMLR_model = MultipleLinearRegression(2,2)\nprint(\"The parameters: \", list(MLR_model.parameters()))\n```", "```py\nThe parameters:  [Parameter containing:\ntensor([[ 0.2236, -0.0123],\n        [ 0.5534, -0.5024]], requires_grad=True), Parameter containing:\ntensor([ 0.0445, -0.4826], requires_grad=True)]\n```", "```py\n# defining the model optimizer\noptimizer = torch.optim.SGD(MLR_model.parameters(), lr=0.1)\n# defining the loss criterion\ncriterion = torch.nn.MSELoss()\n```", "```py\n# Creating the dataloader\ntrain_loader = DataLoader(dataset=data_set, batch_size=2)\n```", "```py\n# Train the model\nlosses = []\nepochs = 20\nfor epoch in range(epochs):\n    for x,y in train_loader:\n        y_pred = MLR_model(x)\n        loss = criterion(y_pred, y)\n        losses.append(loss.item())\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()   \n    print(f\"epoch = {epoch}, loss = {loss}\")\nprint(\"Done training!\")\n```", "```py\nepoch = 0, loss = 0.052659016102552414\nepoch = 1, loss = 0.13005244731903076\nepoch = 2, loss = 0.13508380949497223\nepoch = 3, loss = 0.1353638768196106\nepoch = 4, loss = 0.13537931442260742\nepoch = 5, loss = 0.13537974655628204\nepoch = 6, loss = 0.13537967205047607\nepoch = 7, loss = 0.13538001477718353\nepoch = 8, loss = 0.13537967205047607\nepoch = 9, loss = 0.13537967205047607\nepoch = 10, loss = 0.13538001477718353\nepoch = 11, loss = 0.13537967205047607\nepoch = 12, loss = 0.13537967205047607\nepoch = 13, loss = 0.13538001477718353\nepoch = 14, loss = 0.13537967205047607\nepoch = 15, loss = 0.13537967205047607\nepoch = 16, loss = 0.13538001477718353\nepoch = 17, loss = 0.13537967205047607\nepoch = 18, loss = 0.13537967205047607\nepoch = 19, loss = 0.13538001477718353\nDone training!\n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.plot(losses)\nplt.xlabel(\"no. of iterations\")\nplt.ylabel(\"total loss\")\nplt.show()\n```", "```py\nimport matplotlib.pyplot as plt\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\ntorch.manual_seed(42)\n\n# Creating the dataset class\nclass Data(Dataset):\n    # Constructor\n    def __init__(self):\n        self.x = torch.zeros(40, 2)\n        self.x[:, 0] = torch.arange(-2, 2, 0.1)\n        self.x[:, 1] = torch.arange(-2, 2, 0.1)\n        w = torch.tensor([[1.0, 2.0], [2.0, 4.0]])\n        b = 1\n        func = torch.mm(self.x, w) + b    \n        self.y = func + 0.2 * torch.randn((self.x.shape[0],1))\n        self.len = self.x.shape[0]\n    # Getter\n    def __getitem__(self, idx):          \n        return self.x[idx], self.y[idx] \n    # getting data length\n    def __len__(self):\n        return self.len\n\n# Creating dataset object\ndata_set = Data()\n\n# Creating a custom Multiple Linear Regression Model\nclass MultipleLinearRegression(torch.nn.Module):\n    # Constructor\n    def __init__(self, input_dim, output_dim):\n        super(MultipleLinearRegression, self).__init__()\n        self.linear = torch.nn.Linear(input_dim, output_dim)\n    # Prediction\n    def forward(self, x):\n        y_pred = self.linear(x)\n        return y_pred\n\n# Creating the model object\nMLR_model = MultipleLinearRegression(2,2)\nprint(\"The parameters: \", list(MLR_model.parameters()))\n\n# defining the model optimizer\noptimizer = torch.optim.SGD(MLR_model.parameters(), lr=0.1)\n# defining the loss criterion\ncriterion = torch.nn.MSELoss()\n\n# Creating the dataloader\ntrain_loader = DataLoader(dataset=data_set, batch_size=2)\n\n# Train the model\nlosses = []\nepochs = 20\nfor epoch in range(epochs):\n    for x,y in train_loader:\n        y_pred = MLR_model(x)\n        loss = criterion(y_pred, y)\n        losses.append(loss.item())\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()   \n    print(f\"epoch = {epoch}, loss = {loss}\")\nprint(\"Done training!\")\n\n# Plot the losses\nplt.plot(losses)\nplt.xlabel(\"no. of iterations\")\nplt.ylabel(\"total loss\")\nplt.show()\n```"]