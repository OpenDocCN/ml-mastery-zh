["```py\nfrom numpy import array\nfrom numpy import random\nfrom numpy import dot\nfrom scipy.special import softmax\n\n# importing the Python debugger module\nimport pdb\n\n# encoder representations of four different words\nword_1 = array([1, 0, 0])\nword_2 = array([0, 1, 0])\nword_3 = array([1, 1, 0])\nword_4 = array([0, 0, 1])\n\n# stacking the word embeddings into a single array\nwords = array([word_1, word_2, word_3, word_4])\n\n# generating the weight matrices\nrandom.seed(42)\nW_Q = random.randint(3, size=(3, 3))\nW_K = random.randint(3, size=(3, 3))\nW_V = random.randint(3, size=(3, 3))\n\n# generating the queries, keys and values\nQ = dot(words, W_Q)\nK = dot(words, W_K)\nV = dot(words, W_V)\n\n# inserting a breakpoint\npdb.set_trace()\n\n# scoring the query vectors against all key vectors\nscores = dot(Q, K.transpose())\n\n# computing the weights by a softmax operation\nweights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n\n# computing the attention by a weighted sum of the value vectors\nattention = dot(weights, V)\n\nprint(attention)\n```", "```py\n/Users/mlm/main.py(33)<module>()\n-> scores = dot(Q, K.transpose())\n(Pdb) n\n> /Users/mlm/main.py(36)<module>()\n-> weights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n(Pdb) c\n[[0.98522025 1.74174051 0.75652026]\n [0.90965265 1.40965265 0.5       ]\n [0.99851226 1.75849334 0.75998108]\n [0.99560386 1.90407309 0.90846923]]\n```", "```py\nfrom numpy import array\nfrom numpy import random\nfrom scipy.special import softmax\n\n# encoder representations of four different words\nword_1 = array([1, 0, 0])\nword_2 = array([0, 1, 0])\nword_3 = array([1, 1, 0])\nword_4 = array([0, 0, 1])\n\n# stacking the word embeddings into a single array\nwords = array([word_1, word_2, word_3, word_4])\n\n# generating the weight matrices\nrandom.seed(42)\nW_Q = random.randint(3, size=(3, 3))\nW_K = random.randint(3, size=(3, 3))\nW_V = random.randint(3, size=(3, 3))\n\n# generating the queries, keys and values\nQ = words @ W_Q\nK = words @ W_K\nV = words @ W_V\n\n# inserting a breakpoint\nbreakpoint()\n\n# scoring the query vectors against all key vectors\nscores = Q @ K.transpose()\n\n# computing the weights by a softmax operation\nweights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n\n# computing the attention by a weighted sum of the value vectors\nattention = weights @ V\n\nprint(attention)\n```", "```py\nPYTHONBREAKPOINT=0 python main.py\n```", "```py\nfrom numpy import array\nfrom numpy import random\nfrom scipy.special import softmax\n\n# setting the value of the PYTHONBREAKPOINT environment variable\nimport os\nos.environ['PYTHONBREAKPOINT'] = '0'\n\n# encoder representations of four different words\nword_1 = array([1, 0, 0])\nword_2 = array([0, 1, 0])\nword_3 = array([1, 1, 0])\nword_4 = array([0, 0, 1])\n\n# stacking the word embeddings into a single array\nwords = array([word_1, word_2, word_3, word_4])\n\n# generating the weight matrices\nrandom.seed(42)\nW_Q = random.randint(3, size=(3, 3))\nW_K = random.randint(3, size=(3, 3))\nW_V = random.randint(3, size=(3, 3))\n\n# generating the queries, keys and values\nQ = words @ W_Q\nK = words @ W_K\nV = words @ W_V\n\n# inserting a breakpoint\nbreakpoint()\n\n# scoring the query vectors against all key vectors\nscores = Q @ K.transpose()\n\n# computing the weights by a softmax operation\nweights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n\n# computing the attention by a weighted sum of the value vectors\nattention = weights @ V\n\nprint(attention)\n```", "```py\nPYTHONBREAKPOINT=ipdb.set_trace python main.py\n```", "```py\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy37/main.py(33)<module>()\n     32 # scoring the query vectors against all key vectors\n---> 33 scores = Q @ K.transpose()\n     34 \n\nipdb> n\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy37/main.py(36)<module>()\n     35 # computing the weights by a softmax operation\n---> 36 weights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n     37 \n\nipdb> c\n[[0.98522025 1.74174051 0.75652026]\n [0.90965265 1.40965265 0.5       ]\n [0.99851226 1.75849334 0.75998108]\n [0.99560386 1.90407309 0.90846923]]\n```", "```py\n...\n\n# defining our breakpoint() function\ndef breakpoint(*args, **kwargs):\n    import importlib\n    # reading the value of the environment variable\n    val = os.environ.get('PYTHONBREAKPOINT')\n    # if the value has been set to 0, skip all breakpoints\n    if val == '0':\n        return None\n    # else if the value is an empty string, invoke the default pdb debugger\n    elif len(val) == 0:\n        hook_name = 'pdb.set_trace'\n    # else, assign the value of the environment variable\n    else:\n        hook_name = val\n    # split the string into the module name and the function name\n    mod, dot, func = hook_name.rpartition('.')\n    # get the function from the module\n    module = importlib.import_module(mod)\n    hook = getattr(module, func)\n\n    return hook(*args, **kwargs)\n\n...\n```", "```py\nfrom numpy import array\nfrom numpy import random\nfrom numpy import dot\nfrom scipy.special import softmax\n\n# setting the value of the environment variable\nimport os\nos.environ['PYTHONBREAKPOINT'] = ''\n\n# defining our breakpoint() function\ndef breakpoint(*args, **kwargs):\n    import importlib\n    # reading the value of the environment variable\n    val = os.environ.get('PYTHONBREAKPOINT')\n    # if the value has been set to 0, skip all breakpoints\n    if val == '0':\n        return None\n    # else if the value is an empty string, invoke the default pdb debugger\n    elif len(val) == 0:\n        hook_name = 'pdb.set_trace'\n    # else, assign the value of the environment variable\n    else:\n        hook_name = val\n    # split the string into the module name and the function name\n    mod, dot, func = hook_name.rpartition('.')\n    # get the function from the module\n    module = importlib.import_module(mod)\n    hook = getattr(module, func)\n\n    return hook(*args, **kwargs)\n\n# encoder representations of four different words\nword_1 = array([1, 0, 0])\nword_2 = array([0, 1, 0])\nword_3 = array([1, 1, 0])\nword_4 = array([0, 0, 1])\n\n# stacking the word embeddings into a single array\nwords = array([word_1, word_2, word_3, word_4])\n\n# generating the weight matrices\nrandom.seed(42)\nW_Q = random.randint(3, size=(3, 3))\nW_K = random.randint(3, size=(3, 3))\nW_V = random.randint(3, size=(3, 3))\n\n# generating the queries, keys and values\nQ = dot(words, W_Q)\nK = dot(words, W_K)\nV = dot(words, W_V)\n\n# inserting a breakpoint\nbreakpoint()\n\n# scoring the query vectors against all key vectors\nscores = dot(Q, K.transpose())\n\n# computing the weights by a softmax operation\nweights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n\n# computing the attention by a weighted sum of the value vectors\nattention = dot(weights, V)\n\nprint(attention)\n```", "```py\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy27/main.py(32)breakpoint()->None\n-> return hook(*args, **kwargs)\n(Pdb) n\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy27/main.py(59)<module>()\n-> scores = dot(Q, K.transpose())\n(Pdb) n\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy27/main.py(62)<module>()\n-> weights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n(Pdb) c\n[[0.98522025 1.74174051 0.75652026]\n [0.90965265 1.40965265 0.5       ]\n [0.99851226 1.75849334 0.75998108]\n [0.99560386 1.90407309 0.90846923]]\n```", "```py\nos.environ['PYTHONBREAKPOINT'] = 'ipdb.set_trace'\n```", "```py\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy27/main.py(31)breakpoint()\n     30 \n---> 31     return hook(*args, **kwargs)\n     32 \n\nipdb> n\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy27/main.py(58)<module>()\n     57 # scoring the query vectors against all key vectors\n---> 58 scores = dot(Q, K.transpose())\n     59 \n\nipdb> n\n> /Users/Stefania/Documents/PycharmProjects/BreakpointPy27/main.py(61)<module>()\n     60 # computing the weights by a softmax operation\n---> 61 weights = softmax(scores / K.shape[1] ** 0.5, axis=1)\n     62 \n\nipdb> c\n[[0.98522025 1.74174051 0.75652026]\n [0.90965265 1.40965265 0.5       ]\n [0.99851226 1.75849334 0.75998108]\n [0.99560386 1.90407309 0.90846923]]\n```", "```py\nos.environ['PYTHONBREAKPOINT'] = '0'\n```", "```py\n[[0.98522025 1.74174051 0.75652026]\n [0.90965265 1.40965265 0.5       ]\n [0.99851226 1.75849334 0.75998108]\n [0.99560386 1.90407309 0.90846923]]\n```", "```py\ntry:\n    func()\nexcept:\n    breakpoint()\n    print(\"exception!\")\n```", "```py\nimport sys\nimport pdb\n\ndef debughook(etype, value, tb):\n    pdb.pm() # post-mortem debugger\nsys.excepthook = debughook\n```", "```py\nimport sys\nimport pdb\nimport random\n\ndef debughook(etype, value, tb):\n    pdb.pm() # post-mortem debugger\nsys.excepthook = debughook\n\n# Experimentally find the average of 1/x where x is a random integer in 0 to 9999\nN = 1000\nrandomsum = 0\nfor i in range(N):\n    x = random.randint(0,10000)\n    randomsum += 1/x\n\nprint(\"Average is\", randomsum/N)\n```", "```py\n> /Users/mlm/py_pmhook.py(17)<module>()\n-> randomsum += 1/x\n(Pdb) p i\n16\n(Pdb) p x\n0\n```", "```py\nimport sys\nimport pdb\nimport traceback\n\ndef debughook(etype, value, tb):\n    traceback.print_exception(etype, value, tb)\n    print() # make a new line before launching post-mortem\n    pdb.pm() # post-mortem debugger\nsys.excepthook = debughook\n```", "```py\nTraceback (most recent call last):\n  File \"/Users/mlm/py_pmhook.py\", line 17, in <module>\n    randomsum += 1/x\nZeroDivisionError: division by zero\n\n> /Users/mlm/py_pmhook.py(17)<module>()\n-> randomsum += 1/x\n(Pdb)\n```"]