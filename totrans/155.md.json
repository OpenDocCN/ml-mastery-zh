["```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n```", "```py\n# Creating our dataset class\nclass Build_Data(Dataset):\n    # Constructor\n    def __init__(self, train = True):\n        self.x = torch.arange(-3, 3, 0.1).view(-1, 1)\n        self.func = -5 * self.x + 1\n        self.y = self.func + 0.4 * torch.randn(self.x.size())\n        self.len = self.x.shape[0]\n        # adding some outliers\n        if train == True:\n            self.y[10:12] = 0\n            self.y[30:35] = 25\n        else:\n            pass                \n    # Getting the data\n    def __getitem__(self, index):    \n        return self.x[index], self.y[index]    \n    # Getting length of the data\n    def __len__(self):\n        return self.len\n\ntrain_set = Build_Data()\nval_set = Build_Data(train=False)\n```", "```py\n# Plotting and visualizing the data points\nplt.plot(train_set.x.numpy(), train_set.y.numpy(), 'b+', label='y')\nplt.plot(train_set.x.numpy(), train_set.func.numpy(), 'r', label='func')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid('True', color='y')\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\n# Creating our dataset class\nclass Build_Data(Dataset):\n    # Constructor\n    def __init__(self, train = True):\n        self.x = torch.arange(-3, 3, 0.1).view(-1, 1)\n        self.func = -5 * self.x + 1\n        self.y = self.func + 0.4 * torch.randn(self.x.size())\n        self.len = self.x.shape[0]\n        # adding some outliers\n        if train == True:\n            self.y[10:12] = 0\n            self.y[30:35] = 25\n        else:\n            pass\n    # Getting the data\n    def __getitem__(self, index):\n        return self.x[index], self.y[index]\n    # Getting length of the data\n    def __len__(self):\n        return self.len\n\ntrain_set = Build_Data()\nval_set = Build_Data(train=False)\n\n# Plotting and visualizing the data points\nplt.plot(train_set.x.numpy(), train_set.y.numpy(), 'b+', label='y')\nplt.plot(train_set.x.numpy(), train_set.func.numpy(), 'r', label='func')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.grid('True', color='y')\nplt.show()\n```", "```py\n...\nmodel = torch.nn.Linear(1, 1)\ncriterion = torch.nn.MSELoss()\ntrainloader = DataLoader(dataset=train_set, batch_size=1)\n```", "```py\n...\nlearning_rates = [0.1, 0.01, 0.001, 0.0001]\ntrain_err = torch.zeros(len(learning_rates))\nval_err = torch.zeros(len(learning_rates))\nModels = []\n```", "```py\n...\nepochs = 20\n\n# iterate through the list of various learning rates \nfor i, learning_rate in enumerate(learning_rates):\n    model = torch.nn.Linear(1, 1)\n    optimizer = torch.optim.SGD(model.parameters(), lr = learning_rate)\n    for epoch in range(epochs):\n        for x, y in trainloader:\n            y_hat = model(x)\n            loss = criterion(y_hat, y)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n    # training data\n    Y_hat = model(train_set.x)\n    train_loss = criterion(Y_hat, train_set.y)\n    train_err[i] = train_loss.item()\n\n    # validation data\n    Y_hat = model(val_set.x)\n    val_loss = criterion(Y_hat, val_set.y)\n    val_err[i] = val_loss.item()\n    Models.append(model)\n```", "```py\nplt.semilogx(np.array(learning_rates), train_err.numpy(), label = 'total training loss')\nplt.semilogx(np.array(learning_rates), val_err.numpy(), label = 'total validation loss')\nplt.ylabel('Total Loss')\nplt.xlabel('learning rate')\nplt.legend()\nplt.show()\n```", "```py\n# plotting the predictions on validation data\nfor model, learning_rate in zip(Models, learning_rates):\n    yhat = model(val_set.x)\n    plt.plot(val_set.x.numpy(), yhat.detach().numpy(), label = 'learning rate:' + str(learning_rate))\nplt.plot(val_set.x.numpy(), val_set.func.numpy(), 'or', label = 'validation data')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()\n```", "```py\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\n# Creating our dataset class\nclass Build_Data(Dataset):\n    # Constructor\n    def __init__(self, train=True):\n        self.x = torch.arange(-3, 3, 0.1).view(-1, 1)\n        self.func = -5 * self.x + 1\n        self.y = self.func + 0.4 * torch.randn(self.x.size())\n        self.len = self.x.shape[0]\n        # adding some outliers\n        if train == True:\n            self.y[10:12] = 0\n            self.y[30:35] = 25\n        else:\n            pass\n    # Getting the data\n    def __getitem__(self, index):\n        return self.x[index], self.y[index]\n    # Getting length of the data\n    def __len__(self):\n        return self.len\n\ntrain_set = Build_Data()\nval_set = Build_Data(train=False)\n\ncriterion = torch.nn.MSELoss()\ntrainloader = DataLoader(dataset=train_set, batch_size=1)\n\nlearning_rates = [0.1, 0.01, 0.001, 0.0001]\ntrain_err = torch.zeros(len(learning_rates))\nval_err = torch.zeros(len(learning_rates))\nModels = []\n\nepochs = 20\n\n# iterate through the list of various learning rates \nfor i, learning_rate in enumerate(learning_rates):\n    model = torch.nn.Linear(1, 1)\n    optimizer = torch.optim.SGD(model.parameters(), lr = learning_rate)\n    for epoch in range(epochs):\n        for x, y in trainloader:\n            y_hat = model(x)\n            loss = criterion(y_hat, y)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n\n    # training data\n    Y_hat = model(train_set.x)\n    train_loss = criterion(Y_hat, train_set.y)\n    train_err[i] = train_loss.item()\n\n    # validation data\n    Y_hat = model(val_set.x)\n    val_loss = criterion(Y_hat, val_set.y)\n    val_err[i] = val_loss.item()\n    Models.append(model)\n\nplt.semilogx(np.array(learning_rates), train_err.numpy(), label = 'total training loss')\nplt.semilogx(np.array(learning_rates), val_err.numpy(), label = 'total validation loss')\nplt.ylabel('Total Loss')\nplt.xlabel('learning rate')\nplt.legend()\nplt.show()\n\n# plotting the predictions on validation data\nfor model, learning_rate in zip(Models, learning_rates):\n    yhat = model(val_set.x)\n    plt.plot(val_set.x.numpy(), yhat.detach().numpy(), label = 'learning rate:' + str(learning_rate))\nplt.plot(val_set.x.numpy(), val_set.func.numpy(), 'or', label = 'validation data')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()\n```"]