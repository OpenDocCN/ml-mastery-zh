["```py\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass Data(Dataset):\n    def __init__(self):\n        # Create tensor of 100 values from -50 to 50\n        self.x = torch.zeros(100, 1)\n\n        # Create tensor of zeros with the same shape as x\n        self.y = torch.zeros(self.x.shape)\n\n        # Set the values in x and y using a for loop\n        for i in range(100):\n            self.x[i] = -50 + i\n            if self.x[i,0] > -20 and self.x[i,0] < 20:\n                self.y[i] = 1\n            elif (self.x[i,0] > -30 and self.x[i,0] < -20) or (self.x[i,0] > 20 and self.x[i,0] < 30):\n                self.y[i] = 0\n            elif (self.x[i,0] > -40 and self.x[i,0] < -30) or (self.x[i,0] > 30 and self.x[i,0] < 40):\n                self.y[i] = 1\n            else:\n                self.y[i] = 0\n\n        # Store the length of the dataset\n        self.len = self.x.shape[0]\n\n    def __getitem__(self, index):\n        # Return the x and y values at the specified index\n        return self.x[index], self.y[index]\n\n    def __len__(self):\n        # Return the length of the dataset\n        return self.len\n```", "```py\n# Create the Data object\ndataset = Data()\n```", "```py\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef plot_data(X, Y, model=None, leg=False):\n    # Get the x and y values from the Data object\n    x = dataset.x\n    y = dataset.y\n\n    # Convert the x and y values to a Pandas series with an index\n    x = pd.Series(x[:, 0], index=range(len(x)))\n    y = pd.Series(y[:, 0], index=range(len(y)))\n\n    # Scatter plot of the x and y values, coloring the points by their labels\n    plt.scatter(x, y, c=y)\n\n    if model!=None:\n        plt.plot(X.numpy(), model(X).detach().numpy(), label='Neural Net')\n\n    # Show the plot\n    plt.show()\n```", "```py\nplot_data(dataset.x, dataset.y, leg=False)\n```", "```py\nimport torch.nn as nn\n\n# Define the Neural Network\nclass NeuralNetwork(nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super().__init__()\n        # Define the layers in the neural network\n        self.input_layer = nn.Linear(input_size, hidden_size)\n        self.output_layer = nn.Linear(hidden_size, output_size)\n\n    def forward(self, x):\n        # Define the forward pass through the network\n        x = torch.sigmoid(self.input_layer(x))\n        x = torch.sigmoid(self.output_layer(x))\n        return x\n\n# Initialize the Neural Network\nmodel = NeuralNetwork(input_size=1, hidden_size=20, output_size=1)\n```", "```py\nlearning_rate = 0.01\ncriterion = nn.BCELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\ndata_loader = DataLoader(dataset=dataset, batch_size=32)\n```", "```py\nn_epochs = 7000 # number of epochs to train the model\nLOSS = [] # list to store the loss values after each epoch\n\n# train the model for n_epochs\nfor epoch in range(n_epochs):\n    total = 0 # variable to store the total loss for this epoch   \n    # iterate over the data in the data loader\n    for x, y in data_loader:\n        # zero the gradients of the model\n        optimizer.zero_grad()\n        # make a prediction using the model\n        yhat = model(x)\n        # compute the loss between the predicted and true values\n        loss = criterion(yhat, y)        \n        # compute the gradients of the model with respect to the loss\n        loss.backward()        \n        # update the model parameters\n        optimizer.step()        \n        # add the loss value to the total loss for this epoch\n        total += loss.item()        \n    # after each epoch, check if the epoch number is divisible by 200\n    if epoch % 1000 == 0:\n        # if it is, plot the current data and model using the PlotData function\n        plot_data(dataset.x, dataset.y, model)\n        # print the current loss\n        print(f\"Epochs Done: {epoch+1}/{n_epochs}, Loss: {loss.item():.4f}\")    \n    # add the total loss for this epoch to the LOSS list\n    LOSS.append(total)\n```", "```py\n# plot after training loop ended\nplot_data(dataset.x, dataset.y, model)\n```", "```py\n# create a plot of the loss over epochs\nplt.figure()\nplt.plot(LOSS)\nplt.xlabel('epochs')\nplt.ylabel('loss')\n# show the plot\nplt.show()\n```", "```py\n# Define the Neural Network\nclass NeuralNetwork(nn.Module):\n    def __init__(self, input_size, hidden1_size, hidden2_size, output_size):\n        super(NeuralNetwork, self).__init__()\n\n        # Define the layers in the neural network\n        self.layer1 = nn.Linear(input_size, hidden1_size)\n        self.layer2 = nn.Linear(hidden1_size, hidden2_size)\n        self.output_layer = nn.Linear(hidden2_size, output_size)\n\n    def forward(self, x):\n        # Define the forward pass through the network\n        x = torch.sigmoid(self.layer1(x))\n        x = torch.sigmoid(self.layer2(x))\n        x = torch.sigmoid(self.output_layer(x))\n        return x\n\n# Initialize the Neural Network\nmodel = NeuralNetwork(input_size=1, hidden1_size=10, hidden2_size=10, output_size=1)\n```", "```py\nimport torch.nn as nn\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\n\nclass Data(Dataset):\n    def __init__(self):\n        # Create tensor of 100 values from -50 to 50\n        self.x = torch.zeros(100, 1)\n\n        # Create tensor of zeros with the same shape as x\n        self.y = torch.zeros(self.x.shape)\n\n        # Set the values in x and y using a for loop\n        for i in range(100):\n            self.x[i] = -50 + i\n            if self.x[i,0] > -20 and self.x[i,0] < 20:\n                self.y[i] = 1\n            elif (self.x[i,0] > -30 and self.x[i,0] < -20) or (self.x[i,0] > 20 and self.x[i,0] < 30):\n                self.y[i] = 0\n            elif (self.x[i,0] > -40 and self.x[i,0] < -30) or (self.x[i,0] > 30 and self.x[i,0] < 40):\n                self.y[i] = 1\n            else:\n                self.y[i] = 0\n\n        # Store the length of the dataset\n        self.len = self.x.shape[0]\n\n    def __getitem__(self, index):\n        # Return the x and y values at the specified index\n        return self.x[index], self.y[index]\n\n    def __len__(self):\n        # Return the length of the dataset\n        return self.len\n\n# Create the Data object\ndataset = Data()\n\ndef plot_data(X, Y, model=None, leg=False):\n    # Get the x and y values from the Data object\n    x = dataset.x\n    y = dataset.y\n\n    # Convert the x and y values to a Pandas series with an index\n    x = pd.Series(x[:, 0], index=range(len(x)))\n    y = pd.Series(y[:, 0], index=range(len(y)))\n\n    # Scatter plot of the x and y values, coloring the points by their labels\n    plt.scatter(x, y, c=y)\n\n    if model!=None:\n        plt.plot(X.numpy(), model(X).detach().numpy(), label='Neural Net')\n\n    # Show the plot\n    plt.show()\n\n# Define the Neural Network\nclass NeuralNetwork(nn.Module):\n    def __init__(self, input_size, hidden_size, output_size):\n        super().__init__()\n        # Define the layers in the neural network\n        self.input_layer = nn.Linear(input_size, hidden_size)\n        self.output_layer = nn.Linear(hidden_size, output_size)\n\n    def forward(self, x):\n        # Define the forward pass through the network\n        x = torch.sigmoid(self.input_layer(x))\n        x = torch.sigmoid(self.output_layer(x))\n        return x\n\n# Initialize the Neural Network\nmodel = NeuralNetwork(input_size=1, hidden_size=20, output_size=1)\n\nlearning_rate = 0.01\ncriterion = nn.BCELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\ndata_loader = DataLoader(dataset=dataset, batch_size=32)\n\nn_epochs = 7000 # number of epochs to train the model\nLOSS = [] # list to store the loss values after each epoch\n\n# train the model for n_epochs\nfor epoch in range(n_epochs):\n    total = 0 # variable to store the total loss for this epoch   \n    # iterate over the data in the data loader\n    for x, y in data_loader:\n        # zero the gradients of the model\n        optimizer.zero_grad()\n        # make a prediction using the model\n        yhat = model(x)\n        # compute the loss between the predicted and true values\n        loss = criterion(yhat, y)        \n        # compute the gradients of the model with respect to the loss\n        loss.backward()        \n        # update the model parameters\n        optimizer.step()        \n        # add the loss value to the total loss for this epoch\n        total += loss.item()        \n    # after each epoch, check if the epoch number is divisible by 200\n    if epoch % 1000 == 0:\n        # if it is, plot the current data and model using the PlotData function\n        plot_data(dataset.x, dataset.y, model)\n        # print the current loss\n        print(f\"Epochs Done: {epoch+1}/{n_epochs}, Loss: {loss.item():.4f}\")    \n    # add the total loss for this epoch to the LOSS list\n    LOSS.append(total)\n\nplot_data(dataset.x, dataset.y, model)\n\n# create a plot of the loss over epochs\nplt.figure()\nplt.plot(LOSS)\nplt.xlabel('epochs')\nplt.ylabel('loss')\n# show the plot\nplt.show()\n```"]