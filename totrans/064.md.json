["```py\n# Load the digits image\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Obtain training and testing datasets from the digits image\ndigits_train_imgs, digits_train_labels, digits_test_imgs, digits_test_labels = split_data(20, sub_imgs, 0.8)\n```", "```py\n# Create a new SVM\nsvm_digits = ml.SVM_create()\n\n# Set the SVM kernel to RBF\nsvm_digits.setKernel(ml.SVM_RBF)\nsvm_digits.setType(ml.SVM_C_SVC)\nsvm_digits.setGamma(0.5)\nsvm_digits.setC(12)\nsvm_digits.setTermCriteria((TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 100, 1e-6))\n```", "```py\n# Converting the image data into HOG descriptors\ndigits_train_hog = hog_descriptors(digits_train_imgs)\ndigits_test_hog = hog_descriptors(digits_test_imgs)\n```", "```py\n# Predict labels for the testing data\n_, digits_test_pred = svm_digits.predict(digits_test_hog.astype(float32))\n\n# Compute and print the achieved accuracy\naccuracy_digits = (sum(digits_test_pred.astype(int) == digits_test_labels) / digits_test_labels.size) * 100\nprint('Accuracy:', accuracy_digits[0], '%')\n```", "```py\nAccuracy: 97.1 %\n```", "```py\nfrom cv2 import ml, TERM_CRITERIA_MAX_ITER, TERM_CRITERIA_EPS\nfrom numpy import float32\nfrom digits_dataset import split_images, split_data\nfrom feature_extraction import hog_descriptors\n\n# Load the digits image\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Obtain training and testing datasets from the digits image\ndigits_train_imgs, digits_train_labels, digits_test_imgs, digits_test_labels = split_data(20, sub_imgs, 0.8)\n\n# Create a new SVM\nsvm_digits = ml.SVM_create()\n\n# Set the SVM kernel to RBF\nsvm_digits.setKernel(ml.SVM_RBF)\nsvm_digits.setType(ml.SVM_C_SVC)\nsvm_digits.setGamma(0.5)\nsvm_digits.setC(12)\nsvm_digits.setTermCriteria((TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 100, 1e-6))\n\n# Converting the image data into HOG descriptors\ndigits_train_hog = hog_descriptors(digits_train_imgs)\ndigits_test_hog = hog_descriptors(digits_test_imgs)\n\n# Train the SVM on the set of training data\nsvm_digits.train(digits_train_hog.astype(float32), ml.ROW_SAMPLE, digits_train_labels)\n\n# Predict labels for the testing data\n_, digits_test_pred = svm_digits.predict(digits_test_hog.astype(float32))\n\n# Compute and print the achieved accuracy\naccuracy_digits = (sum(digits_test_pred.astype(int) == digits_test_labels) / digits_test_labels.size) * 100\nprint('Accuracy:', accuracy_digits[0], '%')\n```", "```py\n# Load the digits image\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Obtain training and testing datasets from the digits image\ndigits_train_imgs, _, digits_test_imgs, _ = split_data(20, sub_imgs, 0.8)\n\n# Create an empty list to store the random numbers\nrand_nums = []\n\n# Seed the random number generator for repeatability\nseed(10)\n\n# Choose 25 random digits from the testing dataset\nfor i in range(0, digits_test_imgs.shape[0], int(digits_test_imgs.shape[0] / 25)):\n\n    # Generate a random integer\n    rand = randint(i, int(digits_test_imgs.shape[0] / 25) + i - 1)\n\n    # Append it to the list\n    rand_nums.append(rand)\n\n# Shuffle the order of the generated random integers\nshuffle(rand_nums)\n\n# Read the image data corresponding to the random integers\nrand_test_imgs = digits_test_imgs[rand_nums, :]\n\n# Initialize an array to hold the test image\ntest_img = zeros((100, 100), dtype=uint8)\n\n# Start a sub-image counter\nimg_count = 0\n\n# Iterate over the test image\nfor i in range(0, test_img.shape[0], 20):\n    for j in range(0, test_img.shape[1], 20):\n\n        # Populate the test image with the chosen digits\n        test_img[i:i + 20, j:j + 20] = rand_test_imgs[img_count].reshape(20, 20)\n\n        # Increment the sub-image counter\n        img_count += 1\n\n# Display the test image\nimshow(test_img, cmap='gray')\nshow()\n```", "```py\n# Generate labels for the positive and negative samples\ndigits_train_labels = ones((digits_train_imgs.shape[0], 1), dtype=int)\ndigits_train_labels[int(digits_train_labels.shape[0] / 10):digits_train_labels.shape[0], :] = 0\n\n# Create a new SVM\nsvm_digits = ml.SVM_create()\n\n# Set the SVM kernel to RBF\nsvm_digits.setKernel(ml.SVM_RBF)\nsvm_digits.setType(ml.SVM_C_SVC)\nsvm_digits.setGamma(0.5)\nsvm_digits.setC(12)\nsvm_digits.setTermCriteria((TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 100, 1e-6))\n\n# Convert the training images to HOG descriptors\ndigits_train_hog = hog_descriptors(digits_train_imgs)\n\n# Train the SVM on the set of training data\nsvm_digits.train(digits_train_hog, ml.ROW_SAMPLE, digits_train_labels)\n```", "```py\n# Create an empty list to store the matching patch coordinates\npositive_patches = []\n\n# Define the stride to shift with\nstride = 5\n\n# Iterate over the test image\nfor i in range(0, test_img.shape[0] - 20 + stride, stride):\n    for j in range(0, test_img.shape[1] - 20 + stride, stride):\n\n        # Crop a patch from the test image\n        patch = test_img[i:i + 20, j:j + 20].reshape(1, 400)\n\n        # Convert the image patch into HOG descriptors\n        patch_hog = hog_descriptors(patch)\n\n        # Predict the target label of the image patch\n        _, patch_pred = svm_digits.predict(patch_hog.astype(float32))\n\n        # If a match is found, store its coordinate values\n        if patch_pred == 1:\n            positive_patches.append((i, j))\n\n# Convert the list to an array\npositive_patches = array(positive_patches)\n\n# Iterate over the match coordinates and draw their bounding box\nfor i in range(positive_patches.shape[0]):\n\n    rectangle(test_img, (positive_patches[i, 1], positive_patches[i, 0]),\n              (positive_patches[i, 1] + 20, positive_patches[i, 0] + 20), 255, 1)\n\n# Display the test image\nimshow(test_img, cmap='gray')\nshow()\n```", "```py\nfrom cv2 import ml, TERM_CRITERIA_MAX_ITER, TERM_CRITERIA_EPS, rectangle\nfrom numpy import float32, zeros, ones, uint8, array\nfrom matplotlib.pyplot import imshow, show\nfrom digits_dataset import split_images, split_data\nfrom feature_extraction import hog_descriptors\nfrom random import randint, seed, shuffle\n\n# Load the digits image\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Obtain training and testing datasets from the digits image\ndigits_train_imgs, _, digits_test_imgs, _ = split_data(20, sub_imgs, 0.8)\n\n# Create an empty list to store the random numbers\nrand_nums = []\n\n# Seed the random number generator for repeatability\nseed(10)\n\n# Choose 25 random digits from the testing dataset\nfor i in range(0, digits_test_imgs.shape[0], int(digits_test_imgs.shape[0] / 25)):\n\n    # Generate a random integer\n    rand = randint(i, int(digits_test_imgs.shape[0] / 25) + i - 1)\n\n    # Append it to the list\n    rand_nums.append(rand)\n\n# Shuffle the order of the generated random integers\nshuffle(rand_nums)\n\n# Read the image data corresponding to the random integers\nrand_test_imgs = digits_test_imgs[rand_nums, :]\n\n# Initialize an array to hold the test image\ntest_img = zeros((100, 100), dtype=uint8)\n\n# Start a sub-image counter\nimg_count = 0\n\n# Iterate over the test image\nfor i in range(0, test_img.shape[0], 20):\n    for j in range(0, test_img.shape[1], 20):\n\n        # Populate the test image with the chosen digits\n        test_img[i:i + 20, j:j + 20] = rand_test_imgs[img_count].reshape(20, 20)\n\n        # Increment the sub-image counter\n        img_count += 1\n\n# Display the test image\nimshow(test_img, cmap='gray')\nshow()\n\n# Generate labels for the positive and negative samples\ndigits_train_labels = ones((digits_train_imgs.shape[0], 1), dtype=int)\ndigits_train_labels[int(digits_train_labels.shape[0] / 10):digits_train_labels.shape[0], :] = 0\n\n# Create a new SVM\nsvm_digits = ml.SVM_create()\n\n# Set the SVM kernel to RBF\nsvm_digits.setKernel(ml.SVM_RBF)\nsvm_digits.setType(ml.SVM_C_SVC)\nsvm_digits.setGamma(0.5)\nsvm_digits.setC(12)\nsvm_digits.setTermCriteria((TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 100, 1e-6))\n\n# Convert the training images to HOG descriptors\ndigits_train_hog = hog_descriptors(digits_train_imgs)\n\n# Train the SVM on the set of training data\nsvm_digits.train(digits_train_hog, ml.ROW_SAMPLE, digits_train_labels)\n\n# Create an empty list to store the matching patch coordinates\npositive_patches = []\n\n# Define the stride to shift with\nstride = 5\n\n# Iterate over the test image\nfor i in range(0, test_img.shape[0] - 20 + stride, stride):\n    for j in range(0, test_img.shape[1] - 20 + stride, stride):\n\n        # Crop a patch from the test image\n        patch = test_img[i:i + 20, j:j + 20].reshape(1, 400)\n\n        # Convert the image patch into HOG descriptors\n        patch_hog = hog_descriptors(patch)\n\n        # Predict the target label of the image patch\n        _, patch_pred = svm_digits.predict(patch_hog.astype(float32))\n\n        # If a match is found, store its coordinate values\n        if patch_pred == 1:\n            positive_patches.append((i, j))\n\n# Convert the list to an array\npositive_patches = array(positive_patches)\n\n# Iterate over the match coordinates and draw their bounding box\nfor i in range(positive_patches.shape[0]):\n\n    rectangle(test_img, (positive_patches[i, 1], positive_patches[i, 0]),\n              (positive_patches[i, 1] + 20, positive_patches[i, 0] + 20), 255, 1)\n\n# Display the test image\nimshow(test_img, cmap='gray')\nshow()\n```"]