["```py\nsudo pip install opencv-python tensorflow tf2onnx\n```", "```py\nsudo pip install opencv-contrib-python tensorflow tf2onnx\n```", "```py\nimport cv2\nprint(cv2.version.opencv_version)\n```", "```py\nimport cv2\n\nimage = cv2.imread(\"path/filename.jpg\", cv2.IMREAD_GRAYSCALE)\nprint(image.shape)\n```", "```py\n...\ncv2.imshow(\"My image\", image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\n\nimage = cv2.imread(\"path/filename.jpg\", cv2.IMREAD_GRAYSCALE)\ncv2.imshow(\"My image\", image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n```", "```py\n...\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (25,25), 1)\n```", "```py\ncircles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, dp=1, minDist=100,\n                           param1=80, param2=60, minRadius=90, maxRadius=150)\n```", "```py\nimport cv2\nimport numpy as np\n\nimage_path = \"coins-1.jpg\"\nimg = cv2.imread(image_path)\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (25,25), 1)\ncircles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT,\n                           dp=1, minDist=100,\n                           param1=80, param2=60, minRadius=90, maxRadius=150)\nif circles is not None:\n    for c in np.uint16(np.round(circles[0])):\n        cv2.circle(img, (c[0], c[1]), c[2], (255,0,0), 10)\n        cv2.circle(img, (c[0], c[1]), 2, (0,0,255), 20)\ncv2.imshow(\"Circles\", img)\ncv2.waitKey()\ncv2.destroyAllWindows()\n```", "```py\nred = img[:, :, 2]\n```", "```py\nsubimg = img[y0:y1, x0:x1]\n```", "```py\nimport cv2\nimport numpy as np\n\nimage_path = \"coins-1.jpg\"\nimg = cv2.imread(image_path)\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (25,25), 1)\ncircles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, dp=1, minDist=100,\n                           param1=80, param2=60, minRadius=90, maxRadius=150)\nfor c in np.uint16(np.round(circles[0])):\n    x, y, r = c\n    subimg = img[y-r:y+r, x-r:x+r]\n    cv2.imshow(\"Coin\", subimg)\n    cv2.waitKey(0)\ncv2.destroyAllWindows()\n```", "```py\nimport cv2\n\nreference_path = \"penny.png\"\nsample = cv2.imread(reference_path)\norb = cv2.ORB_create(nfeatures=500)\nkp, ref_desc = orb.detectAndCompute(sample, None)\n```", "```py\n...\nbf = cv2.BFMatcher()\nkp, desc = orb.detectAndCompute(coin_gray, None)\nmatches = bf.knnMatch(ref_desc, desc, k=2)\ncount = len([1 for m, n in matches if m.distance < 0.80*n.distance])\n```", "```py\nimport math\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimage_path = \"coins-1.jpg\"\nreference_path = \"penny.png\"\n\nimg = cv2.imread(image_path)\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (25,25), 1)\ncircles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, dp=1, minDist=100,\n                           param1=80, param2=60, minRadius=90, maxRadius=150)\n\nsample = cv2.imread(reference_path)\norb = cv2.ORB_create(nfeatures=500)\nbf = cv2.BFMatcher()\nkp, ref_desc = orb.detectAndCompute(sample, None)\n\nplt.figure(2)\nN = len(circles[0])\nrows = math.ceil(N / 4)\nfor i, c in enumerate(np.uint16(np.around(circles[0]))):\n    x, y, r = c\n    coin = img[y-r:y+r, x-r:x+r]\n    coin_gray = cv2.cvtColor(coin, cv2.COLOR_BGR2GRAY)\n    kp, desc = orb.detectAndCompute(coin_gray, None)\n    matches = bf.knnMatch(ref_desc, desc, k=2)\n    count = len([1 for m, n in matches if m.distance < 0.80*n.distance])\n    plt.subplot(rows, 4, i+1)\n    plt.imshow(cv2.cvtColor(coin, cv2.COLOR_BGR2RGB))\n    plt.title(f\"{count}\")\n    plt.axis('off')\nplt.show()\n```", "```py\nimport cv2\nimport numpy as np\n\nidx = 1\nfor image_path in [\"coins-2.jpg\", \"coins-3.jpg\"]:\n    img = cv2.imread(image_path)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    blur = cv2.GaussianBlur(gray, (25,25), 1)\n    circles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT,\n                               dp=1, minDist=100,\n                               param1=80, param2=60, minRadius=90, maxRadius=150)\n\n    for c in np.uint16(np.around(circles[0])):\n        x, y, r = c\n        cv2.imwrite(f\"dataset/{idx}.jpg\", img[y-r:y+r, x-r:x+r])\n        idx += 1\n```", "```py\nimport glob\nimport cv2\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom tensorflow.keras.callbacks import EarlyStopping\nfrom tensorflow.keras.layers import Conv2D, Dense, MaxPooling2D, Flatten\nfrom tensorflow.keras.models import Sequential\n\nimages = []\nlabels = []\nfor filename in glob.glob(\"dataset/pos/*\"):\n    img = cv2.imread(filename)\n    img = cv2.resize(img, (256,256))\n    images.append(img)\n    labels.append(1)\n    for _ in range(3):\n        img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n        images.append(img)\n        labels.append(1)\nfor filename in glob.glob(\"dataset/neg/*\"):\n    img = cv2.imread(filename)\n    img = cv2.resize(img, (256,256))\n    images.append(img)\n    labels.append(0)\n    for _ in range(3):\n        img = cv2.rotate(img, cv2.ROTATE_90_CLOCKWISE)\n        images.append(img)\n        labels.append(0)\n\nimages = np.array(images)\nlabels = np.array(labels)\nX_train, X_test, y_train, y_test = train_test_split(images, labels, test_size=0.3)\n\nmodel = Sequential([\n    Conv2D(16, (5,5), input_shape=(256,256,3), padding=\"same\", activation=\"relu\"),\n    MaxPooling2D((2,2)),\n    Conv2D(32, (5,5), activation=\"relu\"),\n    MaxPooling2D((2,2)),\n    Conv2D(64, (5,5), activation=\"relu\"),\n    MaxPooling2D((2,2)),\n    Conv2D(128, (5,5), activation=\"relu\"),\n    Flatten(),\n    Dense(256, activation=\"relu\"),\n    Dense(1, activation=\"sigmoid\")\n])\n\n# Training\nearlystopping = EarlyStopping(monitor=\"val_loss\", patience=10, restore_best_weights=True)\nmodel.compile(loss=\"binary_crossentropy\", optimizer=\"adagrad\", metrics=[\"accuracy\"])\nmodel.fit(X_train, y_train, validation_data=(X_test, y_test),\n          epochs=200, batch_size=32, callbacks=[earlystopping])\nmodel.save(\"penny.h5\")\n```", "```py\npython -m tf2onnx.convert --keras penny.h5 --output penny.onnx\n```", "```py\nimport cv2\n\nnet = cv2.dnn.readNetFromONNX(\"penny.onnx\")\nnet.setInput(blob)\noutput = float(net.forward())\n```", "```py\nimport math\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimage_path = \"coins-1.jpg\"\nmodel_path = \"penny.onnx\"\n\nimg = cv2.imread(image_path)\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (25,25), 1)\ncircles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT,\n                           dp=1, minDist=100,\n                           param1=80, param2=60, minRadius=90, maxRadius=150)\n\nplt.figure(2)\nN = len(circles[0])\nrows = math.ceil(N / 4)\nnet = cv2.dnn.readNetFromONNX(\"penny2.onnx\")\nfor i, c in enumerate(np.uint16(np.around(circles[0]))):\n    x, y, r = c\n    coin = img[y-r:y+r, x-r:x+r]\n    coin = cv2.resize(coin, (256,256))\n    blob = coin[np.newaxis, ...]\n    net.setInput(blob)\n    score = float(net.forward())\n    plt.subplot(rows, 4, i+1)\n    plt.imshow(cv2.cvtColor(coin, cv2.COLOR_BGR2RGB))\n    plt.title(f\"{score:.2f}\")\n    plt.axis('off')\nplt.show()\n```", "```py\nimport math\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimage_path = \"coins-1.jpg\"\nmodel_path = \"penny.onnx\"\n\nimg = cv2.imread(image_path)\ngray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\nblur = cv2.GaussianBlur(gray, (25,25), 1)\ncircles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, dp=1, minDist=100,\n                           param1=80, param2=60, minRadius=90, maxRadius=150)\npositive = 0\nnegative = 0\nnet = cv2.dnn.readNetFromONNX(model_path)\nfor i, c in enumerate(np.uint16(np.around(circles[0]))):\n    x, y, r = c\n    coin = img[y-r:y+r, x-r:x+r]\n    coin = cv2.resize(coin, (256,256))\n    blob = coin[np.newaxis, ...]\n    net.setInput(blob)\n    score = float(net.forward())\n    if score >= 0.9:\n        positive += 1\n    else:\n        negative += 1\nprint(f\"{positive} out of {positive+negative} coins identified are pennies\")\n```"]