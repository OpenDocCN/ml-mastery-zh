["```py\n# Generate a dataset of 2D data points and their ground truth labels\nx, y_true = make_blobs(n_samples=100, centers=2, cluster_std=5, random_state=15)\n\n# Plot the dataset\nscatter(x[:, 0], x[:, 1], c=y_true)\nshow()\n```", "```py\n# Split the data into training and testing sets\nx_train, x_test, y_train, y_test = ms.train_test_split(x, y_true, test_size=0.2, random_state=10)\n\n# Plot the training and testing datasets\nfig, (ax1, ax2) = subplots(1, 2)\nax1.scatter(x_train[:, 0], x_train[:, 1], c=y_train)\nax1.set_title('Training data')\nax2.scatter(x_test[:, 0], x_test[:, 1], c=y_test)\nax2.set_title('Testing data')\nshow()\n```", "```py\n# Create an empty logistic regression model\nlr = ml.LogisticRegression_create()\n```", "```py\n# Check the default training method\nprint(‘Training Method:’, lr.getTrainMethod())\n```", "```py\nTraining Method: 0\n```", "```py\n# Set the training method to Mini-Batch Gradient Descent and the size of the mini-batch\nlr.setTrainMethod(ml.LogisticRegression_MINI_BATCH)\nlr.setMiniBatchSize(5)\n```", "```py\n# Set the number of iterations\nlr.setIterations(10)\n```", "```py\n# Train the logistic regressor on the set of training data\nlr.train(x_train.astype(float32), ml.ROW_SAMPLE, y_train.astype(float32))\n```", "```py\n# Print the learned coefficients\nprint(lr.get_learnt_thetas())\n```", "```py\n[[-0.02413555 -0.34612912  0.08475047]]\n```", "```py\n# Predict the target labels of the testing data\n_, y_pred = lr.predict(x_test.astype(float32))\n\n# Compute and print the achieved accuracy\naccuracy = (sum(y_pred[:, 0].astype(int) == y_test) / y_test.size) * 100\nprint('Accuracy:', accuracy, ‘%')\n```", "```py\nAccuracy: 95.0 %\n```", "```py\n# Plot the ground truth and predicted class labels\nfig, (ax1, ax2) = subplots(1, 2)\nax1.scatter(x_test[:, 0], x_test[:, 1], c=y_test)\nax1.set_title('Ground Truth Testing data')\nax2.scatter(x_test[:, 0], x_test[:, 1], c=y_pred)\nax2.set_title('Predicted Testing data’)\nshow()\n\n# Print the ground truth and predicted class labels of the testing data\nprint('Ground truth class labels:', y_test, '\\n',\n      'Predicted class labels:', y_pred[:, 0].astype(int))\n```", "```py\nGround truth class labels: [1 1 1 1 1 0 0 1 1 1 0 0 1 0 0 1 1 1 1 0] \nPredicted class labels: [1 1 1 1 1 0 0 1 0 1 0 0 1 0 0 1 1 1 1 0]\n```", "```py\nfrom cv2 import ml\nfrom sklearn.datasets import make_blobs\nfrom sklearn import model_selection as ms\nfrom numpy import float32\nfrom matplotlib.pyplot import scatter, show, subplots\n\n# Generate a dataset of 2D data points and their ground truth labels\nx, y_true = make_blobs(n_samples=100, centers=2, cluster_std=5, random_state=15)\n\n# Plot the dataset\nscatter(x[:, 0], x[:, 1], c=y_true)\nshow()\n\n# Split the data into training and testing sets\nx_train, x_test, y_train, y_test = ms.train_test_split(x, y_true, test_size=0.2, random_state=10)\n\n# Plot the training and testing datasets\nfig, (ax1, ax2) = subplots(1, 2)\nax1.scatter(x_train[:, 0], x_train[:, 1], c=y_train)\nax1.set_title('Training data')\nax2.scatter(x_test[:, 0], x_test[:, 1], c=y_test)\nax2.set_title('Testing data')\nshow()\n\n# Create an empty logistic regression model\nlr = ml.LogisticRegression_create()\n\n# Check the default training method\nprint('Training Method:', lr.getTrainMethod())\n\n# Set the training method to Mini-Batch Gradient Descent and the size of the mini-batch\nlr.setTrainMethod(ml.LogisticRegression_MINI_BATCH)\nlr.setMiniBatchSize(5)\n\n# Set the number of iterations\nlr.setIterations(10)\n\n# Train the logistic regressor on the set of training data\nlr.train(x_train.astype(float32), ml.ROW_SAMPLE, y_train.astype(float32))\n\n# Print the learned coefficients\nprint(lr.get_learnt_thetas())\n\n# Predict the target labels of the testing data\n_, y_pred = lr.predict(x_test.astype(float32))\n\n# Compute and print the achieved accuracy\naccuracy = (sum(y_pred[:, 0].astype(int) == y_test) / y_test.size) * 100\nprint('Accuracy:', accuracy, '%')\n\n# Plot the ground truth and predicted class labels\nfig, (ax1, ax2) = subplots(1, 2)\nax1.scatter(x_test[:, 0], x_test[:, 1], c=y_test)\nax1.set_title('Ground truth testing data')\nax2.scatter(x_test[:, 0], x_test[:, 1], c=y_pred)\nax2.set_title('Predicted testing data')\nshow()\n\n# Print the ground truth and predicted class labels of the testing data\nprint('Ground truth class labels:', y_test, '\\n',\n      'Predicted class labels:', y_pred[:, 0].astype(int))\n```"]