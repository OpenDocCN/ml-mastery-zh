- en: Python Classes and Their Use in Keras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://machinelearningmastery.com/python-classes-and-their-use-in-keras/](https://machinelearningmastery.com/python-classes-and-their-use-in-keras/)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Classes are one of the fundamental building blocks of the Python language, which
    may be applied in the development of machine learning applications. As we shall
    see, the Python syntax for developing classes is simple and can be applied to
    implement callbacks in Keras.
  prefs: []
  type: TYPE_NORMAL
- en: In this tutorial, you will discover the Python classes and their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing this tutorial, you will know:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Python classes are important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define and instantiate a class and set its attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create methods and pass arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is class inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use classes to implement callbacks in Keras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kick-start your project** with my new book [Python for Machine Learning](https://machinelearningmastery.com/python-for-machine-learning/),
    including *step-by-step tutorials* and the *Python source code* files for all
    examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started.[![](../Images/26748d693af04db3b853759f183d5d68.png)](https://machinelearningmastery.com/wp-content/uploads/2021/12/s-migaj-Yui5vfKHuzs-unsplash-scaled.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Python Classes and Their Use in Keras
  prefs: []
  type: TYPE_NORMAL
- en: Photo by [S Migaj](https://unsplash.com/photos/Yui5vfKHuzs), some rights reserved.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tutorial Overview**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This tutorial is divided into six parts; they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiation and Attribute References
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Methods and Passing Arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Classes in Keras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Introduction to Classes**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In object-oriented languages, such as Python, classes are one of the fundamental
    building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '*They can be likened to blueprints for an object, as they define what properties
    and methods/behaviors an object should have.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – [Python Fundamentals](https://www.amazon.com/Python-Fundamentals-practical-learning-real-world-ebook/dp/B07K4CVYND/ref=sr_1_1?keywords=python+fundamentals+ebook&qid=1638986660&sr=8-1),
    2018.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Creating a new class creates a new object, where every class instance can be
    characterized by its attributes to maintain its state and methods to modify its
    state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining a Class**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *class* keyword allows for the creation of a new class definition, immediately
    followed by the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, a new class object bound to the specified class name (*MyClass*,
    in this case) is created. Each class object can support instantiation and attribute
    references, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instantiation and Attribute References**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instantiation is the creation of a new instance of a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new instance of a class, we can call it using its class name and
    assign it to a variable. This will create a new, empty class object:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Upon creating a new instance of a class, Python calls its object constructor
    method, *__init()__*, which often takes arguments that are used to set the instantiated
    object’s attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '*We can define this constructor method in our class just like a function and
    specify attributes that will need to be passed in when instantiating an object.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – [Python Fundamentals](https://www.amazon.com/Python-Fundamentals-practical-learning-real-world-ebook/dp/B07K4CVYND/ref=sr_1_1?keywords=python+fundamentals+ebook&qid=1638986660&sr=8-1),
    2018.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let’s say, for instance, that we would like to define a new class named *Dog*:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the constructor method takes two arguments, *name* and *breed*, which
    can be passed to it upon instantiating the object:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the example that we are considering, *name* and *breed* are known as *instance
    variables* (or attributes) because they are bound to a specific instance. This
    means that such attributes belong *only* to the object in which they have been
    set but not to any other object instantiated from the same class.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, *family* is a *class variable* (or attribute) because it
    is shared by all instances of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: You may also note that the first argument of the constructor method (or any
    other method) is often called *self*. This argument refers to the object that
    we are in the process of creating. It is good practice to follow the convention
    of setting the first argument to *self* to ensure the readability of your code
    for other programmers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have set our object’s attributes, they can be accessed using the dot
    operator. For example, considering again the *dog1* instance of the *Dog* class,
    its *name* attribute may be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Want to Get Started With Python for Machine Learning?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take my free 7-day email crash course now (with sample code).
  prefs: []
  type: TYPE_NORMAL
- en: Click to sign-up and also get a free PDF Ebook version of the course.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Methods and Passing Arguments**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to having a constructor method, a class object can also have several
    other methods for modifying its state.
  prefs: []
  type: TYPE_NORMAL
- en: '*The syntax for defining an instance method is familiar. We pass the argument
    self … It is always the first argument of an instance method.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – [Python Fundamentals](https://www.amazon.com/Python-Fundamentals-practical-learning-real-world-ebook/dp/B07K4CVYND/ref=sr_1_1?keywords=python+fundamentals+ebook&qid=1638986660&sr=8-1),
    2018.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Similar to the constructor method, each instance method can take several arguments,
    with the first one being the argument *self* that lets us set and access the object’s
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Different methods of the same object can also use the *self* argument to call
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'An output string can then be generated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We find that, in doing so, the *barks on command* input is appended to the
    *tricks* list when the *info()* method calls the *add_tricks()* method. The following
    output is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Class Inheritance**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another feature that Python supports is class *inheritance*.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a mechanism that allows a *subclass* (also known as a *derived*
    or *child* class) to access all attributes and methods of a *superclass* (also
    known as a *base* or *parent* class).
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for using a subclass is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible that a subclass inherits from multiple base classes, too.
    In this case, the syntax would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Class attributes and methods are searched for in the base class and also in
    subsequent base classes in the case of multiple inheritances.
  prefs: []
  type: TYPE_NORMAL
- en: Python further allows a method in a subclass to override another method in the
    base class that carries the same name. An overriding method in the subclass may
    be replacing the base class method or simply extending its capabilities. When
    an overriding subclass method is available, it is this method that is executed
    when called, rather than the method with the same name in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Classes in Keras**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A practical use of classes in Keras is to write one’s own callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: A callback is a powerful tool in Keras that allows us to look at our model’s
    behavior during the different stages of training, testing, and prediction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed, we may pass a list of callbacks to any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: keras.Model.fit()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: keras.Model.evaluate()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: keras.Model.predict()
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Keras API comes with several built-in callbacks. Nonetheless, we might
    wish to write our own, and for this purpose, we shall look at how to build a *custom*
    callback class. In order to do so, we can inherit several methods from the callback
    base class, which can provide us with information of when:'
  prefs: []
  type: TYPE_NORMAL
- en: Training, testing, and prediction starts and ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An epoch starts and ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A training, testing, and prediction batch starts and ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s first consider a simple example of a custom callback that reports back
    every time that an epoch starts and ends. We will name this custom callback class,
    *EpochCallback*, and override the epoch-level methods, *on_epoch_begin()* and
    *on_epoch_end(),* from the base class, *keras.callbacks.Callback*:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test the custom callback that we have just defined, we need a model
    to train. For this purpose, let’s define a simple Keras model:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a dataset to train on, for which purpose we will be using the
    MNIST dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try out the custom callback by adding it to the list of callbacks
    that we pass as input to the *keras.Model.fit()* method:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback that we have just created produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can create another custom callback that monitors the loss value at the end
    of each epoch and stores the model weights only if the loss has decreased. To
    this end, we will be reading the loss value from the *log* dict, which stores
    the metrics at the end of each batch and epoch. We will also be accessing the
    model corresponding to the current round of training, testing, or prediction,
    by means of *self.model*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s call this custom callback, *CheckpointCallback*:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try this out again, this time including the *CheckpointCallback* into
    the list of callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output of the two callbacks together is now produced:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Other classes in Keras
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides callbacks, we can also make derived classes in Keras for custom metrics
    (derived from `keras.metrics.Metrics`), custom layers (derived from `keras.layers.Layer`),
    custom regularizer (derived from `keras.regularizers.Regularizer`), or even custom
    models (derived from `keras.Model`, for such as changing the behavior of invoking
    a model). All you have to do is follow the guideline to change the member functions
    of a class. You must use exactly the same name and parameters in the member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example from Keras documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This reveals why we would need a class for the custom metric: A metric is not
    just a function but a function that computes its value incrementally, once per
    batch of training data during the training cycle. Eventually, the result is reported
    at the `result()` function at the end of an epoch and reset its memory using the
    `reset_state()` function so you can start afresh in the next epoch.'
  prefs: []
  type: TYPE_NORMAL
- en: For the details on what exactly has to be derived, you should refer to Keras’
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section provides more resources on the topic if you are looking to go deeper.
  prefs: []
  type: TYPE_NORMAL
- en: '**Books**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Python Fundamentals](https://www.amazon.com/Python-Fundamentals-practical-learning-real-world-ebook/dp/B07K4CVYND/ref=sr_1_1?keywords=python+fundamentals+ebook&qid=1638986660&sr=8-1),
    2018.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Websites**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python classes, [https://docs.python.org/3/tutorial/classes.html](https://docs.python.org/3/tutorial/classes.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom callback in Keras, [https://www.tensorflow.org/guide/keras/custom_callback](https://www.tensorflow.org/guide/keras/custom_callback)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom metrics in Keras, [https://keras.io/api/metrics/#creating-custom-metrics](https://keras.io/api/metrics/#creating-custom-metrics)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making new layers and models via subclassing, [https://keras.io/guides/making_new_layers_and_models_via_subclassing/](https://keras.io/guides/making_new_layers_and_models_via_subclassing/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, you discovered Python classes and their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, you learned:'
  prefs: []
  type: TYPE_NORMAL
- en: Why Python classes are important
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define and instantiate a class and set its attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create methods and pass arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is class inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use classes to implement callbacks in Keras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have any questions?
  prefs: []
  type: TYPE_NORMAL
- en: Ask your questions in the comments below, and I will do my best to answer.
  prefs: []
  type: TYPE_NORMAL
