["```py\nimport torch\nfrom torch.utils.data import Dataset\n\n# Creating the dataset class\nclass Data(Dataset):\n    # Constructor\n    def __init__(self):\n        self.x = torch.arange(-2, 2, 0.1).view(-1, 1)\n        self.y = torch.zeros(self.x.shape[0], 1)\n        self.y[self.x[:, 0] > 0.2] = 1\n        self.len = self.x.shape[0]\n    # Getter\n    def __getitem__(self, idx):          \n        return self.x[idx], self.y[idx] \n    # getting data length\n    def __len__(self):\n        return self.len\n```", "```py\n# Creating dataset object\ndata_set = Data()\n```", "```py\n# build custom module for logistic regression\nclass LogisticRegression(torch.nn.Module):    \n    # build the constructor\n    def __init__(self, n_inputs):\n        super().__init__()\n        self.linear = torch.nn.Linear(n_inputs, 1)\n    # make predictions\n    def forward(self, x):\n        y_pred = torch.sigmoid(self.linear(x))\n        return y_pred\n```", "```py\nlog_regr = LogisticRegression(1)\n```", "```py\nprint(\"checking parameters: \", log_regr.state_dict())\n```", "```py\nchecking parameters:  OrderedDict([('linear.weight', tensor([[-0.0075]])), ('linear.bias', tensor([0.5364]))])\n```", "```py\n...\noptimizer = torch.optim.SGD(log_regr.parameters(), lr=2)\n# binary cross-entropy\ncriterion = torch.nn.BCELoss()\n```", "```py\n# load data into the dataloader\ntrain_loader = DataLoader(dataset=data_set, batch_size=2)\n# Train the model\nLoss = []\nepochs = 50\nfor epoch in range(epochs):\n    for x,y in train_loader:\n        y_pred = log_regr(x)\n        loss = criterion(y_pred, y)\n        Loss.append(loss.item())\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()   \n    print(f\"epoch = {epoch}, loss = {loss}\")\nprint(\"Done!\")\n```", "```py\nchecking weights:  OrderedDict([('linear.weight', tensor([[-5.]])), ('linear.bias', tensor([-10.]))])\n```", "```py\nimport matplotlib.pyplot as plt\n\nplt.plot(Loss)\nplt.xlabel(\"no. of iterations\")\nplt.ylabel(\"total loss\")\nplt.show()\n```", "```py\n# get the model predictions on test data\ny_pred = log_regr(data_set.x)\nlabel = y_pred > 0.5 # setting the threshold between zero and one.\nprint(\"model accuracy on test data: \",\n      torch.mean((label == data_set.y.type(torch.ByteTensor)).type(torch.float)))\n```", "```py\nmodel accuracy on test data:  tensor(1.)\n```", "```py\nimport matplotlib.pyplot as plt \nimport torch\nfrom torch.utils.data import Dataset, DataLoader\ntorch.manual_seed(0)\n\n# Creating the dataset class\nclass Data(Dataset):\n    def __init__(self):\n        self.x = torch.arange(-2, 2, 0.1).view(-1, 1)\n        self.y = torch.zeros(self.x.shape[0], 1)\n        self.y[self.x[:, 0] > 0.2] = 1\n        self.len = self.x.shape[0]\n\n    def __getitem__(self, idx):          \n        return self.x[idx], self.y[idx] \n\n    def __len__(self):\n        return self.len\n\n# building dataset object\ndata_set = Data()\n\n# build custom module for logistic regression\nclass LogisticRegression(torch.nn.Module):    \n    # build the constructor\n    def __init__(self, n_inputs):\n        super().__init__()\n        self.linear = torch.nn.Linear(n_inputs, 1)\n    # make predictions\n    def forward(self, x):\n        y_pred = torch.sigmoid(self.linear(x))\n        return y_pred\n\nlog_regr = LogisticRegression(1)\nprint(\"checking parameters: \", log_regr.state_dict())\n\noptimizer = torch.optim.SGD(log_regr.parameters(), lr=2)\n# binary cross-entropy\ncriterion = torch.nn.BCELoss()\n\n# load data into the dataloader\ntrain_loader = DataLoader(dataset=data_set, batch_size=2)\n# Train the model\nLoss = []\nepochs = 50\nfor epoch in range(epochs):\n    for x,y in train_loader:\n        y_pred = log_regr(x)\n        loss = criterion(y_pred, y)\n        Loss.append(loss.item())\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()   \n    print(f\"epoch = {epoch}, loss = {loss}\")\nprint(\"Done!\")\n\nplt.plot(Loss)\nplt.xlabel(\"no. of iterations\")\nplt.ylabel(\"total loss\")\nplt.show()\n\n# get the model predictions on test data\ny_pred = log_regr(data_set.x)\nlabel = y_pred > 0.5 # setting the threshold between zero and one.\nprint(\"model accuracy on test data: \",\n      torch.mean((label == data_set.y.type(torch.ByteTensor)).type(torch.float)))\n```"]