["```py\ndef repeat(fn):\n    fn()\n    fn()\n\ndef hello_world():\n    print(\"Hello world!\")\n\nrepeat(hello_world)\n```", "```py\ndef repeat_decorator(fn):\n    def decorated_fn():\n        fn()\n        fn()\n    # returns a function\n    return decorated_fn\n\ndef hello_world():\n    print (\"Hello world!\")\n\nhello_world_twice = repeat_decorator(hello_world)\n\n# call the function\nhello_world_twice()\n```", "```py\ndef repeat_decorator(fn):\n    def decorated_fn():\n        fn()\n        fn()\n    # returns a function\n    return decorated_fn\n\ndef hello_world():\n    print (\"Hello world!\")\n\nhello_world = repeat_decorator(hello_world)\n\n# call the function\nhello_world()\n```", "```py\n# function decorator that calls the function twice\ndef repeat_decorator(fn):\n    def decorated_fn():\n        fn()\n        fn()\n    # returns a function\n    return decorated_fn\n\n# using the decorator on hello_world function\n@repeat_decorator\ndef hello_world():\n    print (\"Hello world!\")\n\n# call the function\nhello_world()\n```", "```py\ndef repeat_decorator(num_repeats = 2):\n    # repeat_decorator should return a function that's a decorator\n    def inner_decorator(fn):\n        def decorated_fn():\n            for i in range(num_repeats):\n                fn()\n        # return the new function\n        return decorated_fn\n    # return the decorator that actually takes the function in as the input\n    return inner_decorator\n\n# use the decorator with num_repeats argument set as 5 to repeat the function call 5 times\n@repeat_decorator(5)\ndef hello_world():\n    print(\"Hello world!\")\n\n# call the function\nhello_world()\n```", "```py\nHello world!\nHello world!\nHello world!\nHello world!\nHello world!\n```", "```py\n# function decorator to ensure numpy input\ndef ensure_numpy(fn):\n    def decorated_function(data):\n        # converts input to numpy array\n        array = np.asarray(data)\n        # calls fn on input numpy array\n        return fn(array)\n    return decorated_function\n```", "```py\n# function decorator to ensure numpy input\n# and round off output to 4 decimal places\ndef ensure_numpy(fn):\n    def decorated_function(data):\n        array = np.asarray(data)\n        output = fn(array)\n        return np.around(output, 4)\n    return decorated_function\n```", "```py\nimport numpy as np\nimport pandas as pd\n\n# function decorator to ensure numpy input\n# and round off output to 4 decimal places\ndef ensure_numpy(fn):\n    def decorated_function(data):\n        array = np.asarray(data)\n        output = fn(array)\n        return np.around(output, 4)\n    return decorated_function\n\n@ensure_numpy\ndef numpysum(array):\n    return array.sum()\n\nx = np.random.randn(10,3)\ny = pd.DataFrame(x, columns=[\"A\", \"B\", \"C\"])\n\n# output of numpy .sum() function\nprint(\"x.sum():\", x.sum())\nprint()\n\n# output of pandas .sum() funuction\nprint(\"y.sum():\", y.sum())\nprint(y.sum())\nprint()\n\n# calling decorated numpysum function\nprint(\"numpysum(x):\", numpysum(x))\nprint(\"numpysum(y):\", numpysum(y))\n```", "```py\nx.sum(): 0.3948331694737762\n\ny.sum(): A   -1.175484\nB    2.496056\nC   -0.925739\ndtype: float64\nA   -1.175484\nB    2.496056\nC   -0.925739\ndtype: float64\n\nnumpysum(x): 0.3948\nnumpysum(y): 0.3948\n```", "```py\nimport pickle\nimport hashlib\n\nMEMO = {} # To remember the function input and output\n\ndef memoize(fn):\n    def _deco(*args, **kwargs):\n        # pickle the function arguments and obtain hash as the store keys\n        key = (fn.__name__, hashlib.md5(pickle.dumps((args, kwargs), 4)).hexdigest())\n        # check if the key exists\n        if key in MEMO:\n            ret = pickle.loads(MEMO[key])\n        else:\n            ret = fn(*args, **kwargs)\n            MEMO[key] = pickle.dumps(ret)\n        return ret\n    return _deco\n\n@memoize\ndef fibonacci(n):\n    if n in [0, 1]:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(40))\nprint(MEMO)\n```", "```py\n102334155\n{('fibonacci', '635f1664f168e2a15b8e43f20d45154b'): b'\\x80\\x04K\\x01.',\n('fibonacci', 'd238998870ae18a399d03477dad0c0a8'): b'\\x80\\x04K\\x00.',\n('fibonacci', 'dbed6abf8fcf4beec7fc97f3170de3cc'): b'\\x80\\x04K\\x01.',\n...\n('fibonacci', 'b9954ff996a4cd0e36fffb09f982b08e'): b'\\x80\\x04\\x95\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00J)pT\\x02.',\n('fibonacci', '8c7aba62def8063cf5afe85f42372f0d'): b'\\x80\\x04\\x95\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00J\\xa2\\x0e\\xc5\\x03.',\n('fibonacci', '6de8535f23d756de26959b4d6e1f66f6'): b'\\x80\\x04\\x95\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00J\\xcb~\\x19\\x06.'}\n```", "```py\n...\n\nimport pandas_datareader as pdr\n\n@memoize\ndef get_stock_data(ticker):\n    # pull data from stooq\n    df = pdr.stooq.StooqDailyReader(symbols=ticker, start=\"1/1/00\", end=\"31/12/21\").read()\n    return df\n\n#testing call to function\nimport cProfile as profile\nimport pstats\n\nfor i in range(1, 3):\n    print(f\"Run {i}\")\n    run_profile = profile.Profile()\n    run_profile.enable()\n    get_stock_data(\"^DJI\")\n    run_profile.disable()\n    pstats.Stats(run_profile).print_stats(0)\n```", "```py\nRun 1\n         17492 function calls (17051 primitive calls) in 1.452 seconds\n\nRun 2\n         221 function calls (218 primitive calls) in 0.001 seconds\n```", "```py\nimport functools\n\nimport pandas_datareader as pdr\n\n# memoize using lru_cache\n@functools.lru_cache\ndef get_stock_data(ticker):\n    # pull data from stooq\n    df = pdr.stooq.StooqDailyReader(symbols=ticker, start=\"1/1/00\", end=\"31/12/21\").read()\n    return df\n\n# testing call to function\nimport cProfile as profile\nimport pstats\n\nfor i in range(1, 3):\n    print(f\"Run {i}\")\n    run_profile = profile.Profile()\n    run_profile.enable()\n    get_stock_data(\"^DJI\")\n    run_profile.disable()\n    pstats.Stats(run_profile).print_stats(0)\n```", "```py\n# activation.py\n\nACTIVATION = {}\n\ndef register(name):\n    def decorator(fn):\n        # assign fn to \"name\" key in ACTIVATION\n        ACTIVATION[name] = fn\n        # return fn unmodified\n        return fn\n    return decorator\n\ndef activate(x, kind):\n    try:\n        fn = ACTIVATION[kind]\n        return fn(x)\n    except KeyError:\n        print(\"Activation function %s undefined\" % kind)\n```", "```py\n# funcs.py\n\nfrom activation import register\nimport numpy as np\n\n@register(\"relu\")\ndef relu(x):\n    return np.where(x>0, x, 0)\n\n@register(\"sigmoid\")\ndef sigm(x):\n    return 1/(1+np.exp(-x))\n\n@register(\"tanh\")\ndef tanh(x):\n    return np.tanh(x)\n```", "```py\nimport numpy as np\nfrom activation import activate\n\n# create a random matrix\nx = np.random.randn(5,3)\nprint(x)\n\n# try ReLU activation on the matrix\nrelu_x = activate(x, \"relu\")\nprint(relu_x)\n\n# load the functions, and call ReLU activation again\nimport funcs\nrelu_x = activate(x, \"relu\")\nprint(relu_x)\n```", "```py\n[[-0.81549502 -0.81352867  1.41539545]\n [-0.28782853 -1.59323543 -0.19824959]\n [ 0.06724466 -0.26622761 -0.41893662]\n [ 0.47927331 -1.84055276 -0.23147207]\n [-0.18005588 -1.20837815 -1.34768876]]\nActivation function relu undefined\nNone\n[[0\\.         0\\.         1.41539545]\n [0\\.         0\\.         0\\.        ]\n [0.06724466 0\\.         0\\.        ]\n [0.47927331 0\\.         0\\.        ]\n [0\\.         0\\.         0\\.        ]]\n```", "```py\nlayer = keras.layers.Dense(128, activation=\"relu\")\n\nmodel.compile(loss=\"sparse_categorical_crossentropy\",\n              optimizer=\"adam\",\n              metrics=[\"sparse_categorical_accuracy\"])\n```", "```py\nlayer = keras.layers.Dense(128, activation=keras.activations.relu)\n\nmodel.compile(loss=keras.losses.SparseCategoricalCrossentropy(), \n              optimizer=keras.optimizers.Adam(),\n              metrics=[keras.metrics.SparseCategoricalAccuracy()])\n```"]