["```py\n# Load the digits image and divide it into sub-images\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Create the ground truth labels\nimgs, labels_true, _, _ = split_data(20, sub_imgs, 1.0)\n```", "```py\n# Check the shape of the 'imgs' array\nprint(imgs.shape)\n```", "```py\n(5000, 400)\n```", "```py\n# Specify the algorithm's termination criteria\ncriteria = (TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 10, 1.0)\n\n# Run the k-means clustering algorithm on the image data\ncompactness, clusters, centers = kmeans(data=imgs.astype(float32), K=10, bestLabels=None, criteria=criteria, attempts=10, flags=KMEANS_RANDOM_CENTERS)\n```", "```py\n# Reshape array into 20x20 images\nimgs_centers = centers.reshape(-1, 20, 20)\n\n# Visualise the cluster centers\nfig, ax = subplots(2, 5)\n\nfor i, center in zip(ax.flat, imgs_centers):\n    i.imshow(center)\n\nshow()\n```", "```py\n# Found cluster labels\nlabels = array([2, 0, 7, 5, 1, 4, 6, 9, 3, 8])\n\nlabels_pred = zeros(labels_true.shape, dtype='int')\n\n# Re-order the cluster labels\nfor i in range(10):\n    mask = clusters.ravel() == i\n    labels_pred[mask] = labels[i]\n```", "```py\n# Calculate the algorithm's accuracy\naccuracy = (sum(labels_true == labels_pred) / labels_true.size) * 100\n\n# Print the accuracy\nprint(\"Accuracy: {0:.2f}%\".format(accuracy[0]))\n```", "```py\nAccuracy: 54.80%\n```", "```py\nfrom cv2 import kmeans, TERM_CRITERIA_MAX_ITER, TERM_CRITERIA_EPS, KMEANS_RANDOM_CENTERS\nfrom numpy import float32, array, zeros\nfrom matplotlib.pyplot import show, imshow, subplots\nfrom digits_dataset import split_images, split_data\n\n# Load the digits image and divide it into sub-images\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Create the ground truth labels\nimgs, labels_true, _, _ = split_data(20, sub_imgs, 1.0)\n\n# Check the shape of the 'imgs' array\nprint(imgs.shape)\n\n# Specify the algorithm's termination criteria\ncriteria = (TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 10, 1.0)\n\n# Run the k-means clustering algorithm on the image data\ncompactness, clusters, centers = kmeans(data=imgs.astype(float32), K=10, bestLabels=None, criteria=criteria, attempts=10, flags=KMEANS_RANDOM_CENTERS)\n\n# Reshape array into 20x20 images\nimgs_centers = centers.reshape(-1, 20, 20)\n\n# Visualise the cluster centers\nfig, ax = subplots(2, 5)\n\nfor i, center in zip(ax.flat, imgs_centers):\n    i.imshow(center)\n\nshow()\n\n# Cluster labels\nlabels = array([2, 0, 7, 5, 1, 4, 6, 9, 3, 8])\n\nlabels_pred = zeros(labels_true.shape, dtype='int')\n\n# Re-order the cluster labels\nfor i in range(10):\n    mask = clusters.ravel() == i\n    labels_pred[mask] = labels[i]\n\n# Calculate the algorithm's accuracy\naccuracy = (sum(labels_true == labels_pred) / labels_true.size) * 100\n```", "```py\nfrom sklearn.metrics import confusion_matrix\n\n# Print confusion matrix\nprint(confusion_matrix(labels_true, labels_pred))\n```", "```py\n[[399   0   2  28   2  23  27   0  13   6]\n [  0 351   0   1   0   1   0   0   1 146]\n [  4  57 315  26   3  14   4   4  38  35]\n [  2   4   3 241   9  12   3   1 141  84]\n [  0   8  58   0 261  27   3  93   0  50]\n [  3   4   0 150  27 190  12   1  53  60]\n [  6  13  83   4   0  13 349   0   0  32]\n [  0  22   3   1 178  10   0 228   0  58]\n [  0  15  16  85  15  18   3   8 260  80]\n [  2   4  23   7 228   8   1 161   1  65]]\n```", "```py\nfrom cv2 import (kmeans, TERM_CRITERIA_MAX_ITER, TERM_CRITERIA_EPS, KMEANS_RANDOM_CENTERS, moments, warpAffine, INTER_CUBIC, WARP_INVERSE_MAP)\nfrom numpy import float32, array, zeros\nfrom matplotlib.pyplot import show, imshow, subplots\nfrom digits_dataset import split_images, split_data\nfrom sklearn.metrics import confusion_matrix\n\n# Load the digits image and divide it into sub-images\nimg, sub_imgs = split_images('Images/digits.png', 20)\n\n# Create the ground truth labels\nimgs, labels_true, _, _ = split_data(20, sub_imgs, 1.0)\n\n# De-skew all dataset images\nimgs_deskewed = zeros(imgs.shape)\n\nfor i in range(imgs_deskewed.shape[0]):\n    new = deskew_image(imgs[i, :].reshape(20, 20))\n    imgs_deskewed[i, :] = new.reshape(1, -1)\n\n# Specify the algorithm's termination criteria\ncriteria = (TERM_CRITERIA_MAX_ITER + TERM_CRITERIA_EPS, 10, 1.0)\n\n# Run the k-means clustering algorithm on the de-skewed image data\ncompactness, clusters, centers = kmeans(data=imgs_deskewed.astype(float32), K=10, bestLabels=None, criteria=criteria, attempts=10, flags=KMEANS_RANDOM_CENTERS)\n\n# Reshape array into 20x20 images\nimgs_centers = centers.reshape(-1, 20, 20)\n\n# Visualise the cluster centers\nfig, ax = subplots(2, 5)\n\nfor i, center in zip(ax.flat, imgs_centers):\n    i.imshow(center)\n\nshow()\n\n# Cluster labels\nlabels = array([9, 5, 6, 4, 2, 3, 7, 8, 1, 0])\n\nlabels_pred = zeros(labels_true.shape, dtype='int')\n\n# Re-order the cluster labels\nfor i in range(10):\n    mask = clusters.ravel() == i\n    labels_pred[mask] = labels[i]\n\n# Calculate the algorithm's accuracy\naccuracy = (sum(labels_true == labels_pred) / labels_true.size) * 100\n\n# Print the accuracy\nprint(\"Accuracy: {0:.2f}%\".format(accuracy[0]))\n\n# Print confusion matrix\nprint(confusion_matrix(labels_true, labels_pred))\n\ndef deskew_image(img):\n\n    # Calculate the image moments\n    img_moments = moments(img)\n\n    # Moment m02 indicates how much the pixel intensities are spread out along the vertical axis\n    if abs(img_moments['mu02']) > 1e-2:\n\n        # Calculate the image skew\n        img_skew = (img_moments['mu11'] / img_moments['mu02'])\n\n        # Generate the transformation matrix\n        # (We are here tweaking slightly the approximation of vertical translation due to skew by making use of a\n        # scaling factor of 0.6, because we empirically found that this value worked better for this application)\n        m = float32([[1, img_skew, -0.6 * img.shape[0] * img_skew], [0, 1, 0]])\n\n        # Apply the transformation matrix to the image\n        img_deskew = warpAffine(src=img, M=m, dsize=img.shape, flags=INTER_CUBIC | WARP_INVERSE_MAP)\n\n    else:\n\n        # If the vertical spread of pixel intensities is small, return a copy of the original image\n        img_deskew = img.copy()\n\n    return img_deskew\n```", "```py\nAccuracy: 70.92%\n\n[[400   1   5   1   2  58  27   1   1   4]\n [  0 490   1   1   0   1   2   0   1   4]\n [  5  27 379  28  10   2   3   4  30  12]\n [  1  27   7 360   7  44   2   9  31  12]\n [  1  29   3   0 225   0  13   1   0 228]\n [  5  12   1  14  24 270  11   0   7 156]\n [  8  40   6   0   6   8 431   0   0   1]\n [  0  39   2   0  48   0   0 377   4  30]\n [  2  32   3  21   8  77   2   0 332  23]\n [  5  13   1   5 158   5   2  28   1 282]]\n```"]