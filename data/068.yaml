- en: Extracting Histogram of Gradients with OpenCV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 OpenCV 提取梯度直方图
- en: 原文：[https://machinelearningmastery.com/opencv_hog/](https://machinelearningmastery.com/opencv_hog/)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://machinelearningmastery.com/opencv_hog/](https://machinelearningmastery.com/opencv_hog/)
- en: Besides the feature descriptor generated by SIFT, SURF, and ORB, as in the [previous
    post](https://machinelearningmastery.com/opencv_sift_surf_orb_keypoints/), the
    Histogram of Oriented Gradients (HOG) is another feature descriptor you can obtain
    using OpenCV. HOG is a robust feature descriptor widely used in computer vision
    and image processing for object detection and recognition tasks. It captures the
    distribution of gradient orientations in an image and provides a powerful representation
    invariant to changes in illumination and shadowing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了由 SIFT、SURF 和 ORB 生成的特征描述符外，如在[之前的帖子](https://machinelearningmastery.com/opencv_sift_surf_orb_keypoints/)中所示，方向梯度直方图（HOG）是另一种使用
    OpenCV 可以获取的特征描述符。HOG 是计算机视觉和图像处理中广泛使用的强大特征描述符，用于对象检测和识别任务。它捕捉图像中梯度方向的分布，并提供了一个强大的表示，不受光照和阴影变化的影响。
- en: 'In this post, you will learn about HOG. Specifically, you will know:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本帖子中，您将学习关于 HOG 的内容。具体来说，您将了解：
- en: What is HOG, and how is it related to an image
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HOG 是什么，它与图像有何关系
- en: How to compute it in OpenCV
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 OpenCV 中计算它
- en: '**Kick-start your project** with my book [Machine Learning in OpenCV](https://machinelearning.samcart.com/products/machine-learning-opencv/).
    It provides **self-study tutorials** with **working code**.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 用我的书[OpenCV 中的机器学习](https://machinelearning.samcart.com/products/machine-learning-opencv/)**开启您的项目**。它提供了**自学教程**和**可运行的代码**。
- en: Let’s get started.![](../Images/efd0e8bb6d4b7717c9992295caca3847.png)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！![](../Images/efd0e8bb6d4b7717c9992295caca3847.png)
- en: Extracting Histogram of Gradients with OpenCV
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 提取梯度直方图
- en: Photo by [Alexas_Fotos](https://unsplash.com/photos/white-and-black-piglet-on-gray-rocky-ground-during-daytime-A0qtF_zwx_M).
    Some rights reserved.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 照片由[Alexas_Fotos](https://unsplash.com/photos/white-and-black-piglet-on-gray-rocky-ground-during-daytime-A0qtF_zwx_M)提供。部分权利保留。
- en: '**Overview**'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**概述**'
- en: 'This post is divided into two parts; they are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本帖子分为两部分；它们是：
- en: Understanding HOG
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 HOG
- en: Computing HOG in OpenCV
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 OpenCV 中计算 HOG
- en: Using HOg for People Detection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HOG 进行人员检测
- en: Understanding HOG
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 HOG
- en: The concept behind the HOG algorithm is to compute the distribution of gradient
    orientations in localized portions of an image. HOG operates on a **window**,
    which is a region of fixed pixel size on the image. A window is divided into small
    spatial regions, known as a **block**, and a block is further divided into multiple
    **cells**. HOG calculates the gradient magnitude and orientation within each cell,
    and creates a histogram of gradient orientations. Then the histograms within the
    same block are concatenated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: HOG 算法背后的概念是计算图像局部区域中梯度方向的分布。HOG 在图像上操作一个**窗口**，即图像上固定像素大小的区域。一个窗口被分为小的空间区域，称为**块**，而块进一步被划分为多个**单元**。HOG
    计算每个单元内的梯度幅度和方向，并创建梯度方向的直方图。然后将同一块内的直方图串联起来。
- en: Gradient measures how a pixel’s color intensity compares to its neighbors. The
    more drastic it changes, the higher the magnitude. The orientation tells which
    direction is the steepest gradient. Usually, this is applied on a single-channel
    image (i.e., grayscale), and each pixel can have its own gradient. HOG gathers
    all gradients from a block and puts them into a histogram.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度衡量像素的颜色强度与其邻域的比较。它的变化越剧烈，幅度越高。方向告诉我们哪个方向是最陡的梯度。通常，这适用于单通道图像（即灰度图像），每个像素可以有自己的梯度。HOG
    收集一个块内的所有梯度，并将它们放入一个直方图中。
- en: The clever way of making a histogram in HOG is that the bins in a histogram
    are determined by the angle, but the value is interpolated between the closest
    bins. For example, if the bins are assigned values 0, 20, 40, and so on while
    the gradient was 10 at angle 30, a value of 5 was added to bins of 20 and 40\.
    This way, HOG can effectively capture the texture and shape of objects within
    the image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HOG 制作直方图的巧妙之处在于，直方图中的箱由角度决定，但值在最接近的箱之间插值。例如，如果箱分配值为 0、20、40，而梯度角度为 30 时，值为
    10，则在 20 和 40 的箱中添加了值 5。这样，HOG 能够有效地捕捉图像中物体的纹理和形状。
- en: HOG is particularly effective for detecting objects with distinguishable textures
    and patterns, making it a popular choice for tasks such as pedestrian detection
    and other forms of object recognition. With its ability to capture the distribution
    of gradient orientations, HOG provides a robust representation invariant to variations
    in lighting conditions and shadows.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: HOG特别适用于检测具有明显纹理和模式的对象，使其成为行人检测和其他形式对象识别任务的热门选择。凭借捕捉梯度方向分布的能力，HOG提供了对光照条件和阴影变化不敏感的强大表示。
- en: Computing HOG in OpenCV
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在OpenCV中计算HOG
- en: 'OpenCV provides a straightforward method to compute the HOG descriptor, making
    it easily accessible for developers and researchers. Let’s take a look at a basic
    example of how to compute HOG in OpenCV:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: OpenCV提供了一种直接的方法来计算HOG描述符，使得开发人员和研究人员都能轻松访问。让我们来看一个在OpenCV中计算HOG的基本示例：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'HOG computes features for one window at a time. There are multiple blocks in
    a window. In a block, there are multiple “cells”. See the following illustration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: HOG一次计算一个窗口的特征。一个窗口中有多个块。在一个块中，有多个“单元格”。见下图：
- en: '![](../Images/1d790511493f51137f98e042930365d7.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/1d790511493f51137f98e042930365d7.png)'
- en: Assume this entire picture is one window. A window is divided into cells (green
    grids), and several cells are combined into one block (red and blue boxes). There
    are many overlapping blocks in one window, but all blocks are the same size.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设整个图像是一个窗口。一个窗口被划分为多个单元格（绿色网格），几个单元格组合成一个块（红色和蓝色框）。一个窗口中有许多重叠的块，但所有块的大小相同。
- en: Each cell is of a fixed size. In the above, you used 64×64 pixels in a cell.
    Each block has an equal number of cells. In the above, you used 4×4 cells in a
    block. Also, there is equal number of cells in a window; you used 8×6 cells above.
    However, we are not dividing an image into blocks or windows when we compute HOG.
    But instead,
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元格的大小是固定的。在上面的示例中，你使用了64×64像素的单元格。每个块有相同数量的单元格。在上面的示例中，你使用了4×4单元格的块。此外，窗口中的单元格数量也是相等的；你使用了8×6单元格。然而，在计算HOG时，我们并没有将图像划分为块或窗口。相反，
- en: Consider a window as a sliding window on the image, in which the sliding window’s
    stride size is the size of one cell, i.e., it slides across one cell at a time
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视窗口为图像上的滑动窗口，其中滑动窗口的步幅大小是一个单元格的大小，即每次滑动一个单元格
- en: We divide the window into cells of fixed size
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将窗口划分为固定大小的单元格
- en: We set up the second sliding window that matches the block size and scan the
    window. It slides across one cell at a time
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置第二个滑动窗口以匹配块大小并扫描窗口。它每次滑动一个单元格
- en: Within a block, HOG is computed from each cell
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个块内，HOG是从每个单元格中计算的
- en: 'The returned HOG is a vector for the entire image. In the code above, you reshaped
    it to make it clear the hierarchy of windows, blocks, cells, and histogram bins.
    For example, `hog_feats[i][j]` corresponds to the window (in numpy slicing syntax):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的HOG是整个图像的一个向量。在上述代码中，你重新塑造它以清晰地显示窗口、块、单元格和直方图箱的层次结构。例如，`hog_feats[i][j]`对应于窗口（以numpy切片语法表示）：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Or, equivalently, the window with the cell (i,j) at the top left corner.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，相当于窗口的左上角是单元格（i,j）。
- en: 'A sliding window is a common technique in object detection because you cannot
    be sure a particular object lies exactly in a grid cell. Making smaller cells
    but larger windows is a better way to catch the object than just seeing a part
    of it. However, there’s a limitation: An object larger than the window will be
    missed. Also, an object too small may be dwarfed by other elements in the window.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动窗口是一种在目标检测中常用的技术，因为你不能确定一个特定对象是否完全位于一个网格单元中。将单元格做得更小，但窗口更大，是捕捉对象的比仅看到部分对象更好的方法。然而，有一个限制：窗口较大的对象会被遗漏。此外，过小的对象可能会被窗口中的其他元素所掩盖。
- en: Usually, you have some downstream tasks associated with HOG, such as running
    an SVM classifier on the HOG features for object detection. In this case, you
    may want to reshape the HOG output into vectors of the entire block rather than
    in the hierarchy of each cell like above.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会有一些与HOG相关的下游任务，例如在HOG特征上运行SVM分类器进行对象检测。在这种情况下，你可能想将HOG输出重新塑造成整个块的向量，而不是像上面那样按单元格的层次结构。
- en: Using HOG for People Detection
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HOG进行人群检测
- en: The feature extraction technique in the code above is useful if you want to
    get the raw feature vectors for other purposes. But for some common tasks, OpenCV
    comes with pre-trained machine learning models for your disposal without much
    effort.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的特征提取技术对于您想要获取其他用途的原始特征向量很有用。但对于一些常见任务，OpenCV 提供了预训练的机器学习模型，您可以轻松使用它们。
- en: 'Let’s consider the photo from the following URL (save it as `people.jpg`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来考虑以下 URL 的照片（保存为 `people.jpg`）：
- en: '[https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY](https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY](https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY)'
- en: '![](../Images/972495e14bef2bf7369802e8639f76ea.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/972495e14bef2bf7369802e8639f76ea.png)'
- en: A photo is used as an example to detect people using HOG.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HOG 检测人的示例照片。
- en: Photo by [Chris Dickens](https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY).
    Some rights reserved.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图片由 [Chris Dickens](https://unsplash.com/photos/people-crossing-on-pedestrian-lane-near-buildings-during-daytime-JfBj_rVOhKY)
    提供。保留所有权利。
- en: 'This is a picture of people crossing a street. OpenCV has a “people detector”
    in HOG that was trained on a 64×128 pixel window size. Using it to detect people
    in a photo is surprisingly simple:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个人们过马路的照片。OpenCV 中的 HOG 有一个经过训练的“人检测器”，其窗口大小为 64×128 像素。用它来检测照片中的人非常简单：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the above, you created a HOG descriptor with the parameters from `cv2.HOGDescriptor_getDefaultPeopleDetector()
    will initialize` an SVM classifier to detect a particular object, which in this
    case is people.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，您使用了`cv2.HOGDescriptor_getDefaultPeopleDetector()`的参数创建了一个 HOG 描述符，它将初始化一个
    SVM 分类器来检测特定对象，在这种情况下是人。
- en: 'You call the descriptor on an image and run the SVM in one pipeline using `hog.detectMultiScale(img)`,
    which returns the **bounding boxes** for each object detected. While the window
    size is fixed, this detection function will resize the image in multiple scales
    to find the best detection result. Even so, the bounding boxes returned are not
    tight. The code above also annotates the people detected by marking the bounding
    box on the image. You may further filter the result using the confidence score
    reported by the detector. Some filtering algorithms, such as non-maximum suppression,
    may be appropriate but are not discussed here. The following is the output:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在图像上调用描述符并使用`hog.detectMultiScale(img)`运行 SVM，该函数返回每个检测到的对象的**边界框**。虽然窗口大小是固定的，但此检测函数会在多个尺度下调整图像大小，以找到最佳检测结果。即便如此，返回的边界框仍然不够紧凑。上面的代码还通过在图像上标记边界框来标注检测到的人。您可以通过检测器报告的置信度分数进一步过滤结果。一些过滤算法，如非极大值抑制，可能适用，但这里不予讨论。以下是输出：
- en: '![](../Images/46e81a2db021d8929caebdda3e9b1b25.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/46e81a2db021d8929caebdda3e9b1b25.png)'
- en: Bounding box as produced by the people detector using HOG in OpenCV
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OpenCV 中的 HOG 生成的边界框
- en: You can see such detectors can find people only if the full body is visible.
    The output has false positives (non-people detected) and false negatives (people
    not detected). Using it to count all people in a crowd scene would be challenging.
    But it is a good start to see how easily you can get something done using OpenCV.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这些检测器只能在全身可见的情况下找到人。输出中包含假阳性（未检测到的人）和假阴性（未检测到的人）。在拥挤的场景中计算所有人可能会很具有挑战性。但这是一个很好的开始，展示了如何使用
    OpenCV 轻松完成任务。
- en: Unfortunately, there are not any detectors that come with OpenCV other than
    people. But you can train your own SVM or other models using the HOG as feature
    vectors. Facilitating a machine learning model is the key point of extracting
    feature vectors from an image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，OpenCV 除了人脸检测器之外，没有其他检测器。但您可以使用 HOG 作为特征向量来训练自己的 SVM 或其他模型。使机器学习模型更为便捷是从图像中提取特征向量的关键点。
- en: Want to Get Started With Machine Learning with OpenCV?
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 想要开始使用 OpenCV 进行机器学习吗？
- en: Take my free email crash course now (with sample code).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 立即参加我的免费电子邮件速成课程（包含示例代码）。
- en: Click to sign-up and also get a free PDF Ebook version of the course.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击注册并获取课程的免费 PDF 电子书版本。
- en: '**Further Reading**'
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: This section provides more resources on the topic if you are looking to go deeper.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了更多关于该主题的资源，供您深入了解。
- en: '**Books**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**书籍**'
- en: '[Mastering OpenCV 4 with Python](https://www.amazon.com/Mastering-OpenCV-Python-practical-processing/dp/1789344913),
    2019.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[精通 OpenCV 4 与 Python](https://www.amazon.com/Mastering-OpenCV-Python-practical-processing/dp/1789344913)，2019年。'
- en: '**Websites**'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**网站**'
- en: OpenCV, [https://opencv.org/](https://opencv.org/)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenCV, [https://opencv.org/](https://opencv.org/)
- en: 'StackOverflow: OpenCV HOG Features Explanation: [https://stackoverflow.com/questions/44972099/opencv-hog-features-explanation](https://stackoverflow.com/questions/44972099/opencv-hog-features-explanation)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'StackOverflow: OpenCV HOG 特征解释: [https://stackoverflow.com/questions/44972099/opencv-hog-features-explanation](https://stackoverflow.com/questions/44972099/opencv-hog-features-explanation)'
- en: '**Summary**'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this tutorial, you learned how to use HOG in OpenCV to extract feature vectors
    based on a sliding window. It is an effective approach to finding features that
    can help object detection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，你学习了如何在 OpenCV 中使用 HOG 来基于滑动窗口提取特征向量。这是一种有效的特征检测方法，有助于对象检测。
- en: 'Specifically, you learned:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你学会了：
- en: How to fetch HOG features from an image
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从图像中提取 HOG 特征
- en: How to use the built-in HOG people detector from OpenCV
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 OpenCV 内置的 HOG 人物检测器
- en: In case you have any questions, please leave a comment below.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有任何问题，请在下方留言。
